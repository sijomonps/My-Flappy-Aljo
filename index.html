<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale-1.0">
    <title>My Flappy Aljo</title>
    
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Load Tone.js for audio -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
    
    <style>
        /* Use Inter font */
        body {
            font-family: 'Inter', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            margin: 0;
            padding: 0;
        }
        /* Ensure canvas is crisp on all displays */
        canvas {
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            touch-action: none; /* Disable touch scrolling on canvas */
        }
        
        /* Responsive layout */
        .game-wrapper {
            display: flex;
            flex-direction: column;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
        }
        
        .game-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            max-height: 100%;
        }
        
        /* Fullscreen on desktop, portrait on mobile */
        @media (min-width: 768px) {
            .game-title {
                font-size: 2.5rem;
                padding: 1rem;
            }
            .canvas-container {
                max-width: 100%;
                width: 100%;
            }
        }
        
        @media (max-width: 767px) {
            .game-title {
                font-size: 1.5rem;
                padding: 0.5rem;
            }
            .canvas-container {
                max-width: 500px;
            }
        }
        
        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes slideDown {
            from { 
                transform: translateY(-50px);
                opacity: 0;
            }
            to { 
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }
        
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        
        .animate-fadeIn {
            animation: fadeIn 0.5s ease-in;
        }
        
        .animate-slideDown {
            animation: slideDown 0.5s ease-out;
        }
        
        .animate-pulse {
            animation: pulse 2s ease-in-out infinite;
        }
        
        .animate-bounce {
            animation: bounce 1s ease-in-out infinite;
        }
        
        .button-hover {
            transition: all 0.3s ease;
        }
        
        .button-hover:hover {
            transform: scale(1.1);
            box-shadow: 0 10px 25px rgba(16, 185, 129, 0.5);
        }
        
        .button-hover:active {
            transform: scale(0.95);
        }
        
        /* Custom Scrollbar */
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }
        
        .custom-scrollbar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
        }
        
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, #06b6d4, #0891b2);
            border-radius: 10px;
        }
        
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(180deg, #0891b2, #06b6d4);
        }
    </style>
</head>
<body class="bg-gray-900 text-white">

    <div class="game-wrapper">
        <!-- The game title will be set by JS from the config -->
        <h1 id="gameTitle" class="game-title font-bold text-center text-cyan-300 flex-shrink-0 animate-slideDown">
            MyFlappy Aljo
        </h1>
        
        <!-- Game container -->
        <div class="game-container">
            <div class="canvas-container bg-gray-800 rounded-lg shadow-2xl overflow-hidden relative mx-auto" style="flex: 1; display: flex; flex-direction: column;">
                <canvas id="gameCanvas" class="w-full h-full"></canvas>
            
            <!-- Start Screen Overlay -->
            <div id="startScreen" class="absolute inset-0 bg-black bg-opacity-70 flex flex-col items-center justify-center p-4 z-10 animate-fadeIn">
                <h2 class="text-2xl md:text-4xl font-bold mb-4 animate-bounce">Ready?</h2>
                <p class="text-sm md:text-base mb-6 text-gray-300 text-center">Click, tap, or press SPACE to flap!</p>
                <button id="startButton" class="button-hover bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-8 rounded-lg text-xl shadow-lg animate-pulse">
                    üöÄ Start Game
                </button>
            </div>

            <!-- Name Entry Screen -->
            <div id="nameEntryScreen" class="absolute inset-0 bg-black bg-opacity-90 flex flex-col items-center justify-center p-4 z-20">
                <div class="bg-gray-800 rounded-xl p-8 max-w-md w-full animate-slideDown">
                    <h2 class="text-3xl md:text-4xl font-bold text-cyan-300 mb-4 text-center">Welcome Player! üéÆ</h2>
                    <p class="text-gray-300 mb-6 text-center">Enter your name to start playing</p>
                    <input type="text" id="playerNameInput" maxlength="20" placeholder="Your Name" 
                           class="w-full px-4 py-3 bg-gray-700 text-white rounded-lg text-center text-xl mb-4 focus:outline-none focus:ring-2 focus:ring-cyan-400">
                    <button id="saveNameButton" class="button-hover w-full bg-cyan-500 hover:bg-cyan-600 text-white font-bold py-3 px-6 rounded-lg text-xl shadow-lg">
                        ‚úÖ Start Playing
                    </button>
                </div>
            </div>

            <!-- Game Over Overlay -->
            <div id="gameOverScreen" class="absolute inset-0 bg-black bg-opacity-90 hidden flex-col items-center p-4 z-10 overflow-y-auto">
                <div class="flex flex-col items-center justify-start w-full max-w-2xl my-auto">
                    <!-- Game Over Title -->
                    <h2 class="text-3xl md:text-5xl font-bold text-red-500 mb-6 animate-slideDown text-center">
                        üí•You Killed Aljo!
                    </h2>
                    
                    <!-- Score Card -->
                    <div class="bg-gradient-to-br from-gray-800 to-gray-900 rounded-2xl p-8 mb-6 w-full animate-fadeIn shadow-2xl border-2 border-gray-700" style="animation-delay: 0.2s;">
                        <div class="text-center mb-4">
                            <p class="text-gray-400 text-sm mb-1">Your Score</p>
                            <p class="text-6xl font-bold text-yellow-400 mb-4">
                                <span id="finalScore">0</span>
                            </p>
                        </div>
                        <div class="flex justify-center items-center gap-4 pt-4 border-t border-gray-700">
                            <div class="text-center">
                                <p class="text-gray-400 text-xs mb-1">Personal Best</p>
                                <p class="text-2xl font-bold text-cyan-400">
                                    <span id="highScore">0</span> üèÜ
                                </p>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Leaderboard -->
                    <div id="leaderboardContainer" class="bg-gradient-to-br from-gray-800 to-gray-900 rounded-2xl p-6 mb-6 w-full animate-fadeIn shadow-2xl border-2 border-gray-700" style="animation-delay: 0.4s;">
                        <div class="flex items-center justify-between mb-4">
                            <h3 class="text-2xl md:text-3xl font-bold text-cyan-300 text-center flex-1">
                                üèÜ Global Leaderboard
                            </h3>
                            <!-- Admin Clear Button (hold Shift and click title to show) -->
                            <button id="clearLeaderboardBtn" class="hidden text-xs bg-red-600 hover:bg-red-700 text-white px-2 py-1 rounded">
                                üóëÔ∏è Clear
                            </button>
                        </div>
                        <div id="leaderboardList" class="space-y-2 max-h-80 overflow-y-auto pr-2 custom-scrollbar">
                            <!-- Leaderboard entries will be inserted here -->
                        </div>
                    </div>
                    
                    <!-- Action Buttons -->
                    <div class="flex flex-col sm:flex-row gap-3 w-full justify-center">
                        <button id="restartButton" class="button-hover bg-green-500 hover:bg-green-600 text-white font-bold py-4 px-8 rounded-xl text-lg shadow-lg flex-1 sm:flex-none">
                            üîÑ Play Again
                        </button>
                        <button id="changeNameButton" class="button-hover bg-purple-500 hover:bg-purple-600 text-white font-bold py-4 px-8 rounded-xl text-lg shadow-lg flex-1 sm:flex-none">
                            ‚úèÔ∏è Change Name
                        </button>
                    </div>
                </div>
            </div>

            <!-- Score Display -->
            <div id="scoreDisplay" class="absolute top-4 left-1/2 -translate-x-1/2 text-4xl md:text-6xl font-bold text-white" style="text-shadow: 3px 3px 6px rgba(0,0,0,0.7); transition: transform 0.2s ease-out;">
                0
            </div>
            
            <!-- Distance Display -->
            <div id="distanceDisplay" class="d-none absolute top-16 md:top-24 left-1/2 -translate-x-1/2 text-lg md:text-2xl font-semibold text-cyan-300 hidden bg-black bg-opacity-40 px-3 py-1 rounded-lg" style="text-shadow: 2px 2px 4px rgba(0,0,0,0.5); transition: all 0.3s ease;">
                <span class="text-xs md:text-sm">üìè Next: </span><span id="distanceValue">0</span><span class="text-xs md:text-sm">m</span>
            </div>
            
            <!-- Player Name Display -->
            <div id="playerNameDisplay" class="absolute bottom-4 left-4 text-sm md:text-lg font-semibold text-white bg-black bg-opacity-50 px-3 py-1 rounded-lg hidden" style="text-shadow: 2px 2px 4px rgba(0,0,0,0.5);">
                üë§ <span id="currentPlayerName"></span>
            </div>
            </div>
        </div>
    </div>

    <script>
        // --- FIREBASE CONFIGURATION ---
        
        // Replace these with your Firebase project credentials
        // Get your config from: https://console.firebase.google.com/
        // Import the functions you need from the SDKs you need

        const firebaseConfig = {
        apiKey: "AIzaSyD-qDhqI3MTJf2eqGsKXae29luSg8UBP1Q",
        authDomain: "my-flappy-aljo.firebaseapp.com",
        databaseURL: "https://my-flappy-aljo-default-rtdb.firebaseio.com",
        projectId: "my-flappy-aljo",
        storageBucket: "my-flappy-aljo.firebasestorage.app",
        messagingSenderId: "941796846018",
        appId: "1:941796846018:web:b8a66260dfff2f80f10e5b"
        };


        
        // Check if Firebase is configured
        const isFirebaseConfigured = firebaseConfig.apiKey !== "YOUR_API_KEY";
        
        // Initialize Firebase
        let database = null;
        let useLocalLeaderboard = true;
        
        if (isFirebaseConfigured && typeof firebase !== 'undefined') {
            try {
                firebase.initializeApp(firebaseConfig);
                database = firebase.database();
                useLocalLeaderboard = false;
                console.log("‚úÖ Firebase initialized successfully");
            } catch (error) {
                console.error("‚ùå Firebase initialization error:", error);
                console.log("üìù Using local leaderboard instead");
                useLocalLeaderboard = true;
            }
        } else {
            console.log("‚ö†Ô∏è Firebase not configured. Using local leaderboard.");
            console.log("üí° To enable online leaderboard, see FIREBASE_SETUP.md");
            useLocalLeaderboard = true;
        }
        
        // --- GLOBAL FUNCTIONS (Define early for console access) ---
        window.clearLeaderboard = function() {
            localStorage.removeItem('flappyLocalLeaderboard');
            console.log('‚úÖ Local leaderboard cleared!');
            
            // Also clear Firebase if connected
            if (database && !useLocalLeaderboard) {
                database.ref('leaderboard').remove()
                    .then(() => {
                        console.log('‚òÅÔ∏è Firebase leaderboard cleared!');
                        alert('‚úÖ Leaderboard cleared (Local + Firebase)! Refresh the page.');
                    })
                    .catch(err => {
                        console.error('‚ùå Error clearing Firebase:', err);
                        alert('‚úÖ Local leaderboard cleared! Refresh the page.');
                    });
            } else {
                alert('‚úÖ Local leaderboard cleared! Refresh the page.');
            }
        };
        
        window.clearAllData = function() {
            // Clear localStorage
            localStorage.removeItem('flappyLocalLeaderboard');
            localStorage.removeItem('flappyPlayerName');
            localStorage.removeItem('flappyPlayerId');
            localStorage.removeItem('flappyHighScore');
            console.log('üóëÔ∏è Local data cleared!');
            
            // Clear Firebase if connected
            if (database && !useLocalLeaderboard) {
                database.ref('leaderboard').remove()
                    .then(() => {
                        console.log('‚òÅÔ∏è Firebase leaderboard cleared!');
                        alert('‚úÖ All data cleared (Local + Firebase)! The page will reload.');
                        return true;
                    })
                    .catch(err => {
                        console.error('‚ùå Error clearing Firebase:', err);
                        alert('‚ö†Ô∏è Local data cleared, but Firebase error. Check console. Refreshing...');
                        return false;
                    });
            } else {
                alert('‚úÖ All local data cleared! The page will reload.');
            }
        };
        
        // --- DEVELOPER CONFIGURATION ---
        // Change the game title here
        const GAME_TITLE = "My Flappy Aljo"; 
        
        // Paths to your assets. Use "" for default bird/sounds.
        // Recommended: Use relative paths (e.g., "assets/bird.png")
        const BIRD_IMAGE_PATH = "./Tools/face-remo.png";
        const FLAP_SOUND_PATH = "./Tools/falp SOund Final.mp3"; // e.g., "audio/my-flap.wav"
        const OUT_SOUND_PATH = "./Tools/out-Fina.mp3";  // e.g., "audio/my-out.mp3"
        
        // Game Difficulty Settings
        const PIPE_GAP = 250; // Gap between top and bottom pipes (smaller = harder)
        const PIPE_SPACING = 440; // Distance between pipes (frames at 60fps: 240 = 4 seconds, 180 = 3 seconds, 120 = 2 seconds)
        // --- END CONFIGURATION ---


        // --- DOM Elements ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        const nameEntryScreen = document.getElementById('nameEntryScreen');
        const playerNameInput = document.getElementById('playerNameInput');
        const saveNameButton = document.getElementById('saveNameButton');
        const changeNameButton = document.getElementById('changeNameButton');
        
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const startButton = document.getElementById('startButton');
        const restartButton = document.getElementById('restartButton');
        
        const scoreDisplay = document.getElementById('scoreDisplay');
        const finalScore = document.getElementById('finalScore');
        const highScoreDisplay = document.getElementById('highScore');
        const distanceDisplay = document.getElementById('distanceDisplay');
        const distanceValue = document.getElementById('distanceValue');
        const playerNameDisplay = document.getElementById('playerNameDisplay');
        const currentPlayerName = document.getElementById('currentPlayerName');
        const leaderboardList = document.getElementById('leaderboardList');

        // --- Game Constants ---
        const BIRD_WIDTH = 90; // "very big" and square
        const BIRD_HEIGHT = 90; // "very big" and square
        const PIPE_WIDTH = 100;
        // PIPE_GAP is now configured in the DEVELOPER CONFIGURATION section above
        const GRAVITY = 0.25; 
        const FLAP_STRENGTH = -7.5; 
        const SPEED = 2.9; 
        const GROUND_HEIGHT = 100;
        const CLOUD_SPEED = 0.5;

        // --- Game State ---
        let bird, pipes, score, highScore, gameover, frame;
        let lastTime = 0; // For delta time calculation
        let deltaTime = 0; // Time since last frame
        let timeSinceLastPipe = 0; // Accumulated time for pipe spawning
        
        // Anti-cheat: Track game integrity
        let gameStartTime = 0;
        let pipesPassed = 0;
        let totalFlaps = 0;
        let gameHash = '';
        
        // Simple hash function for integrity checking
        function simpleHash(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32bit integer
            }
            return Math.abs(hash).toString(36);
        }
        
        // Validate score integrity
        function validateScore(score, time, pipes, flaps) {
            // Score should match pipes passed EXACTLY
            if (score !== pipes) {
                console.error('üö´ Score mismatch:', {score, pipes});
                return false;
            }
            
            // Minimum time validation (2 seconds per pipe minimum)
            const minTimeNeeded = pipes * 2;
            if (time < minTimeNeeded) {
                console.error('üö´ Time too fast:', {time, minTimeNeeded});
                return false;
            }
            
            // Maximum time validation (30 seconds max per pipe)
            const maxTimeAllowed = pipes * 30;
            if (time > maxTimeAllowed) {
                console.error('üö´ Time too slow:', {time, maxTimeAllowed});
                return false;
            }
            
            // Flap validation (min 1, max 5 per pipe on average + 10 for start)
            const minFlapsNeeded = pipes * 1;
            const maxReasonableFlaps = pipes * 5 + 10;
            if (flaps < minFlapsNeeded || flaps > maxReasonableFlaps) {
                console.error('üö´ Flap count suspicious:', {flaps, min: minFlapsNeeded, max: maxReasonableFlaps});
                return false;
            }
            
            // Score bounds check
            if (score < 0 || score > 9999) {
                console.error('üö´ Score out of bounds:', score);
                return false;
            }
            
            // Physics validation - bird velocity should be reasonable
            if (typeof bird !== 'undefined' && Math.abs(bird.velocity) > 50) {
                console.error('üö´ Impossible velocity:', bird.velocity);
                return false;
            }
            
            return true;
        }
        
        // --- Player State ---
        let playerName = localStorage.getItem('flappyPlayerName') || '';
        let playerId = localStorage.getItem('flappyPlayerId') || generatePlayerId();
        
        // --- Local Leaderboard (fallback when Firebase is not configured) ---
        function getLocalLeaderboard() {
            const saved = localStorage.getItem('flappyLocalLeaderboard');
            return saved ? JSON.parse(saved) : [];
        }
        
        function saveToLocalLeaderboard(playerName, score) {
            // Anti-cheat: Re-validate before local save
            const gameTime = (Date.now() - gameStartTime) / 1000;
            if (!validateScore(score, gameTime, pipesPassed, totalFlaps)) {
                console.error('üö´ Invalid score - local save rejected');
                return;
            }
            
            let leaderboard = getLocalLeaderboard();
            
            // Find if player name already exists (check by name, not ID for global competition)
            const existingPlayerIndex = leaderboard.findIndex(entry => 
                entry.playerName.toLowerCase() === playerName.toLowerCase()
            );
            
            if (existingPlayerIndex !== -1) {
                // Player name exists - only update if new score is higher
                if (score > leaderboard[existingPlayerIndex].score) {
                    console.log(`üéâ ${playerName}: New high score! ${leaderboard[existingPlayerIndex].score} ‚Üí ${score}`);
                    leaderboard[existingPlayerIndex].score = score;
                    leaderboard[existingPlayerIndex].playerId = playerId;
                    leaderboard[existingPlayerIndex].timestamp = Date.now();
                } else {
                    console.log(`${playerName}: Score ${score} not better than best ${leaderboard[existingPlayerIndex].score}`);
                    return; // Don't save if not a personal best
                }
            } else {
                // New player name - add to leaderboard
                console.log(`üÜï New player: ${playerName} with score ${score}`);
                leaderboard.push({
                    playerName: playerName,
                    score: score,
                    playerId: playerId,
                    timestamp: Date.now()
                });
            }
            
            // Sort by score descending and keep only top 100
            leaderboard.sort((a, b) => b.score - a.score);
            const top100 = leaderboard.slice(0, 100);
            
            localStorage.setItem('flappyLocalLeaderboard', JSON.stringify(top100));
        }
        
        function clearLocalLeaderboard() {
            localStorage.removeItem('flappyLocalLeaderboard');
            console.log('üóëÔ∏è Local leaderboard cleared');
        }
        
        // --- Background State ---
        let groundOffset, clouds;
        
        // --- Particle Effects ---
        let particles = [];
        
        // --- Seeded Random for Consistent Levels ---
        let seed = 12345; // Fixed seed for consistent pipe generation
        
        function seededRandom() {
            // Linear congruential generator for predictable randomness
            seed = (seed * 1664525 + 1013904223) % 4294967296;
            return seed / 4294967296;
        }

        // --- Player Management ---
        function generatePlayerId() {
            const id = 'player_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            localStorage.setItem('flappyPlayerId', id);
            return id;
        }

        function savePlayerName(name) {
            playerName = name.trim();
            localStorage.setItem('flappyPlayerName', playerName);
            currentPlayerName.textContent = playerName;
        }

        function showNameEntry() {
            nameEntryScreen.classList.remove('hidden');
            nameEntryScreen.style.display = 'flex';
            playerNameInput.value = playerName;
            playerNameInput.focus();
        }

        function hideNameEntry() {
            nameEntryScreen.classList.add('hidden');
            nameEntryScreen.style.display = 'none';
        }

        // --- Firebase Functions ---
        async function saveScoreToFirebase(playerName, score) {
            // Anti-cheat: Validate score before saving
            const gameTime = (Date.now() - gameStartTime) / 1000; // seconds
            const isValid = validateScore(score, gameTime, pipesPassed, totalFlaps);
            
            if (!isValid) {
                console.error('üö´ Invalid score detected! Score rejected.');
                console.log('Debug:', {score, gameTime, pipesPassed, totalFlaps});
                return; // Don't save tampered scores
            }
            
            // Generate integrity hash
            const integrityCheck = simpleHash(
                gameHash + score + pipesPassed + totalFlaps + gameTime.toFixed(2)
            );
            
            console.log('‚úÖ Score validated:', {score, time: gameTime.toFixed(1), pipes: pipesPassed, flaps: totalFlaps, hash: integrityCheck});
            
            // Use local leaderboard if Firebase is not configured
            if (useLocalLeaderboard) {
                console.log("üíæ Saving score to local leaderboard:", {playerName, score});
                saveToLocalLeaderboard(playerName, score);
                return;
            }
            
            if (!database) {
                console.log("Database not initialized, using local leaderboard");
                saveToLocalLeaderboard(playerName, score);
                return;
            }
            
            try {
                // Create a unique key based on player name (case-insensitive)
                const playerKey = playerName.toLowerCase().replace(/[^a-z0-9]/g, '_');
                const leaderboardRef = database.ref('leaderboard/' + playerKey);
                
                // Check if this player name already exists
                const snapshot = await leaderboardRef.once('value');
                const existingData = snapshot.val();
                const currentBest = existingData ? existingData.score : 0;
                
                // Only save if this is a new high score for this player name
                if (score > currentBest) {
                    const timestamp = Date.now();
                    const scoreData = {
                        playerName: playerName, // Keep original capitalization
                        score: score,
                        timestamp: timestamp,
                        playerId: playerId
                    };
                    
                    console.log(`‚òÅÔ∏è ${playerName}: New high score! ${currentBest} ‚Üí ${score}`);
                    
                    // Save to leaderboard (one entry per unique player name)
                    await leaderboardRef.set(scoreData);
                    console.log("‚úÖ Leaderboard updated in Firebase");
                } else {
                    console.log(`${playerName}: Score ${score} not better than best ${currentBest}`);
                }
            } catch (error) {
                console.error("‚ùå Error saving score to Firebase:", error);
                console.log("üíæ Falling back to local leaderboard");
                saveToLocalLeaderboard(playerName, score);
            }
        }

        async function loadLeaderboard() {
            try {
                // Show loading message
                leaderboardList.innerHTML = '<p class="text-gray-400 text-center">Loading leaderboard...</p>';
                
                let scores = [];
                
                // Load from local or Firebase
                if (useLocalLeaderboard) {
                    console.log("üìÇ Loading from local leaderboard");
                    scores = getLocalLeaderboard();
                    
                    // Add info message
                    const infoDiv = document.createElement('div');
                    infoDiv.className = 'text-xs text-gray-400 text-center mb-2 p-2 bg-gray-900 rounded';
                    infoDiv.innerHTML = 'üíæ Local Leaderboard<br><span class="text-xs">Configure Firebase for online leaderboard</span>';
                    leaderboardList.innerHTML = '';
                    leaderboardList.appendChild(infoDiv);
                } else if (database) {
                    console.log("‚òÅÔ∏è Loading from Firebase");
                    
                    // Fetch all leaderboard data from Firebase
                    const snapshot = await database.ref('leaderboard').once('value');
                    
                    // Extract all scores
                    snapshot.forEach(childSnapshot => {
                        const data = childSnapshot.val();
                        if (data && data.playerName && typeof data.score === 'number') {
                            scores.push({
                                playerName: data.playerName,
                                score: data.score,
                                playerId: data.playerId,
                                timestamp: data.timestamp || 0
                            });
                        }
                    });
                }
                
                console.log("üìä Loaded scores:", scores);
                
                // Sort by score in descending order (highest first)
                scores.sort((a, b) => {
                    if (b.score !== a.score) {
                        return b.score - a.score; // Higher score first
                    }
                    return a.timestamp - b.timestamp; // Earlier timestamp if same score
                });
                
                // Display all scores (not just top 10)
                const topScores = scores; // Show all players
                
                // Display leaderboard entries
                if (topScores.length === 0) {
                    const emptyMsg = document.createElement('p');
                    emptyMsg.className = 'text-gray-400 text-center';
                    emptyMsg.textContent = 'No scores yet. Be the first!';
                    leaderboardList.appendChild(emptyMsg);
                } else {
                    topScores.forEach((scoreData, index) => {
                        const rank = index + 1;
                        const isCurrentPlayer = scoreData.playerId === playerId;
                        const medal = rank === 1 ? 'ü•á' : rank === 2 ? 'ü•à' : rank === 3 ? 'ü•â' : `${rank}.`;
                        
                        const entry = document.createElement('div');
                        entry.className = `flex justify-between items-center p-3 rounded transition ${isCurrentPlayer ? 'bg-cyan-700 border-2 border-cyan-400' : 'bg-gray-700'}`;
                        entry.innerHTML = `
                            <div class="flex items-center gap-2">
                                <span class="text-2xl">${medal}</span>
                                <span class="font-semibold text-white">${scoreData.playerName}</span>
                            </div>
                            <span class="text-yellow-400 font-bold text-xl">${scoreData.score}</span>
                        `;
                        leaderboardList.appendChild(entry);
                    });
                }
            } catch (error) {
                console.error("‚ùå Error loading leaderboard:", error);
                leaderboardList.innerHTML = `<p class="text-red-400 text-center text-sm">Error: ${error.message}</p>`;
            }
        }

        // --- Custom Assets ---
        let birdImage = null;
        let flapAudio = null;
        let outAudio = null;

        // --- Default Synths (Tone.js) ---
        let flapSynth, outSynth;

        function initAudio() {
            if (!flapSynth) {
                flapSynth = new Tone.Synth({
                    oscillator: { type: 'sine' },
                    envelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.1 }
                }).toDestination();
                flapSynth.volume.value = 5; // Louder
            }
            if (!outSynth) {
                outSynth = new Tone.NoiseSynth({
                    noise: { type: 'white' },
                    envelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.1 }
                }).toDestination();
                outSynth.volume.value = 5; // Louder
            }
        }

        // --- Asset Handlers ---
        function loadDeveloperAssets() {
            if (BIRD_IMAGE_PATH) {
                birdImage = new Image();
                birdImage.src = BIRD_IMAGE_PATH;
            }
            if (FLAP_SOUND_PATH) {
                flapAudio = new Audio(FLAP_SOUND_PATH);
            }
            if (OUT_SOUND_PATH) {
                outAudio = new Audio(OUT_SOUND_PATH);
            }
        }

        // --- Sound Players ---
        function playFlapSound() {
            if (Tone.context.state !== 'running') {
                Tone.start();
            }
            if (flapAudio) {
                flapAudio.currentTime = 0; 
                flapAudio.play().catch(e => console.error("Error playing flap sound:", e));
            } else {
                initAudio(); 
                flapSynth.triggerRelease();
                flapSynth.triggerAttackRelease("C5", "8n", Tone.now()); 
            }
        }

        function playOutSound() {
            if (outAudio) {
                outAudio.currentTime = 0;
                outAudio.play().catch(e => console.error("Error playing out sound:", e));
            } else {
                initAudio(); 
                outSynth.triggerRelease();
                outSynth.triggerAttackRelease("4n", Tone.now());
            }
        }

        // --- Particle Functions ---
        function createScoreParticles(x, y) {
            for (let i = 0; i < 10; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4 - 2,
                    life: 1.0,
                    size: Math.random() * 4 + 2,
                    color: `hsl(${Math.random() * 60 + 150}, 100%, 50%)` // Green to cyan
                });
            }
        }

        function createFlapParticles(x, y) {
            // Small particles when bird flaps
            for (let i = 0; i < 3; i++) {
                particles.push({
                    x: x,
                    y: y + 20,
                    vx: (Math.random() - 0.5) * 2,
                    vy: Math.random() * 2 + 1,
                    life: 0.5,
                    size: Math.random() * 3 + 1,
                    color: 'rgba(255, 255, 255, 0.8)'
                });
            }
        }

        function createCollisionParticles(x, y) {
            // Explosion effect on collision
            for (let i = 0; i < 20; i++) {
                const angle = (Math.PI * 2 * i) / 20;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * 5,
                    vy: Math.sin(angle) * 5,
                    life: 1.0,
                    size: Math.random() * 5 + 2,
                    color: `hsl(${Math.random() * 60}, 100%, 50%)` // Red to yellow
                });
            }
        }

        function updateParticles(timeScale = 1) {
            particles = particles.filter(p => {
                p.x += p.vx * timeScale;
                p.y += p.vy * timeScale;
                p.vy += 0.2 * timeScale; // Gravity
                p.life -= 0.02 * timeScale;
                return p.life > 0;
            });
        }

        function drawParticles() {
            particles.forEach(p => {
                ctx.save();
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });
        }

        // --- Background Functions ---
        function initBackground() {
            groundOffset = 0;
            clouds = [];
            particles = [];
            const w = canvas.logicalWidth || canvas.width;
            const h = canvas.logicalHeight || canvas.height;
            for (let i = 0; i < 5; i++) {
                clouds.push({
                    x: Math.random() * w,
                    y: Math.random() * (h / 2) + 20, // Top half of screen
                    radius: Math.random() * 20 + 20 // 20-40px radius
                });
            }
        }

        function updateBackground(timeScale = 1) {
            if (gameover) return; // Freeze background on game over
            const w = canvas.logicalWidth;
            groundOffset -= SPEED * timeScale;
            if (groundOffset <= -w) {
                groundOffset = 0;
            }

            clouds.forEach(cloud => {
                cloud.x -= CLOUD_SPEED * timeScale;
                if (cloud.x + cloud.radius * 2 < 0) {
                    cloud.x = w + cloud.radius * 2;
                    cloud.y = Math.random() * (canvas.logicalHeight / 2) + 20;
                }
            });
        }

        function drawBackground(w, h) {
            // Draw clouds with shadows and better rendering
            clouds.forEach(cloud => {
                ctx.save();
                
                // Cloud shadow
                ctx.shadowColor = 'rgba(0, 0, 0, 0.1)';
                ctx.shadowBlur = 10;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;
                
                // Cloud gradient for 3D effect
                const cloudGradient = ctx.createRadialGradient(cloud.x, cloud.y, 0, cloud.x, cloud.y, cloud.radius * 1.5);
                cloudGradient.addColorStop(0, 'rgba(255, 255, 255, 0.95)');
                cloudGradient.addColorStop(0.7, 'rgba(255, 255, 255, 0.85)');
                cloudGradient.addColorStop(1, 'rgba(240, 240, 240, 0.7)');
                ctx.fillStyle = cloudGradient;
                
                ctx.beginPath();
                // Enhanced fluffy cloud shape
                ctx.arc(cloud.x, cloud.y, cloud.radius, 0, Math.PI * 2);
                ctx.arc(cloud.x + cloud.radius * 0.8, cloud.y - cloud.radius * 0.3, cloud.radius * 0.8, 0, Math.PI * 2);
                ctx.arc(cloud.x - cloud.radius * 0.7, cloud.y - cloud.radius * 0.2, cloud.radius * 0.7, 0, Math.PI * 2);
                ctx.arc(cloud.x + cloud.radius * 0.3, cloud.y + cloud.radius * 0.4, cloud.radius * 0.6, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            });

            // Draw ground with gradient and texture
            const groundGradient = ctx.createLinearGradient(0, h - GROUND_HEIGHT, 0, h);
            groundGradient.addColorStop(0, '#10b981'); // Green grass
            groundGradient.addColorStop(0.15, '#059669'); // Darker green
            groundGradient.addColorStop(0.15, '#d4a574'); // Light brown earth
            groundGradient.addColorStop(1, '#a67c52'); // Darker brown

            ctx.fillStyle = groundGradient;
            ctx.fillRect(groundOffset, h - GROUND_HEIGHT, w, GROUND_HEIGHT);
            ctx.fillRect(groundOffset + w, h - GROUND_HEIGHT, w, GROUND_HEIGHT);

            // Add grass texture with small blades
            ctx.fillStyle = '#0d9488'; // Teal for grass variation
            for (let i = 0; i < 50; i++) {
                const x = (groundOffset + (i * w / 25)) % (w * 2);
                const y = h - GROUND_HEIGHT + Math.random() * 5;
                ctx.fillRect(x, y, 2, 8);
            }

            // Add dirt texture
            ctx.fillStyle = 'rgba(139, 90, 43, 0.3)';
            for (let i = 0; i < 30; i++) {
                const x = (groundOffset + (i * w / 15)) % (w * 2);
                const y = h - GROUND_HEIGHT + 20 + Math.random() * (GROUND_HEIGHT - 30);
                ctx.beginPath();
                ctx.arc(x, y, Math.random() * 3 + 1, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // --- Game Setup ---
        function setup() {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            canvas.logicalWidth = rect.width;
            canvas.logicalHeight = rect.height;
            
            initBackground(); // Initialize background elements

            bird = {
                x: canvas.logicalWidth / 3,
                y: canvas.logicalHeight / 2,
                width: BIRD_WIDTH,
                height: BIRD_HEIGHT,
                velocity: 0,
                rotation: 0
            };
            pipes = [];
            score = 0;
            highScore = localStorage.getItem('flappyHighScore') || 0;
            gameover = false;
            frame = 0;
            lastTime = 0; // Reset delta time tracking
            deltaTime = 0; // Reset delta time
            timeSinceLastPipe = 0; // Reset pipe spawn timer
            
            // Anti-cheat: Initialize integrity tracking
            gameStartTime = Date.now();
            pipesPassed = 0;
            totalFlaps = 0;
            gameHash = simpleHash(playerId + gameStartTime + seed);
            
            // Reset seed for consistent pipe generation every game
            seed = 12345;
            
            // Spawn first pipe - further away on mobile for easier start
            const isMobile = window.innerWidth <= 767;
            const firstPipeDistance = isMobile ? 1.2 : 0.6; // Mobile: 120% screen width (off-screen), Desktop: 60%
            
            const dynamicPipeGap = Math.max(150, Math.min(PIPE_GAP, canvas.logicalHeight / 3));
            const minPipeHeight = 50;
            const maxPipeHeight = canvas.logicalHeight - dynamicPipeGap - minPipeHeight - GROUND_HEIGHT;
            const firstPipeHeight = seededRandom() * (maxPipeHeight - minPipeHeight) + minPipeHeight;
            
            pipes.push({
                x: canvas.logicalWidth * firstPipeDistance, // Mobile gets more time to prepare
                top: firstPipeHeight,
                bottom: firstPipeHeight + dynamicPipeGap,
                passed: false,
                isFirstPipe: true // Mark as first pipe for mobile spacing logic
            });
            
            scoreDisplay.textContent = score;
            
            // Smooth transition from start screen to game
            startScreen.style.opacity = '0';
            setTimeout(() => {
                startScreen.classList.add('hidden');
                scoreDisplay.classList.remove('hidden');
                distanceDisplay.classList.remove('hidden');
                scoreDisplay.style.animation = 'slideDown 0.5s ease-out';
            }, 300);
            
            gameOverScreen.classList.add('hidden');
            gameOverScreen.classList.remove('flex');
            
            gameLoop();
        }

        // --- Game Loop ---
        function gameLoop(currentTime = 0) {
            if (gameover) return;
            
            // Calculate delta time (time since last frame in seconds)
            if (lastTime === 0) lastTime = currentTime;
            deltaTime = (currentTime - lastTime) / 1000; // Convert to seconds
            lastTime = currentTime;
            
            // Cap delta time to prevent huge jumps (e.g., when tab is inactive)
            deltaTime = Math.min(deltaTime, 0.1);
            
            update();
            draw();
            frame++;
            requestAnimationFrame(gameLoop);
        }

        // --- Update Logic ---
        function update() {
            // Anti-cheat: Detect if game variables are being tampered with
            if (typeof bird === 'undefined' || typeof pipes === 'undefined' || typeof score === 'undefined') {
                console.error('üö´ Game tampering detected! Variables modified.');
                return endGame();
            }
            
            // Use 60 FPS as baseline (1/60 = 0.0166... seconds per frame)
            const timeScale = deltaTime > 0 ? deltaTime / (1/60) : 1;
            
            bird.velocity += GRAVITY * timeScale;
            bird.y += bird.velocity * timeScale;

            if (bird.velocity < 0) {
                bird.rotation = -0.3; 
            } else {
                bird.rotation = Math.min(Math.PI / 4, bird.velocity * 0.05);
            }

            // Ground collision
            if (bird.y + bird.height / 2 > canvas.logicalHeight - GROUND_HEIGHT) {
                bird.y = canvas.logicalHeight - GROUND_HEIGHT - bird.height / 2;
                bird.velocity = 0;
                return endGame();
            }
            // Sky collision
            if (bird.y - bird.height / 2 < 0) {
                bird.y = bird.height / 2;
                bird.velocity = 0;
            }

            // Pipe management
            // Check if it's time to spawn a new pipe based on elapsed time (not frames)
            // This ensures consistent pipe spacing across all refresh rates
            const pipeSpawnTime = PIPE_SPACING / SPEED / 60; // Time in seconds (60 FPS baseline)
            timeSinceLastPipe += deltaTime;
            
            if (timeSinceLastPipe >= pipeSpawnTime) {
                timeSinceLastPipe = 0; // Reset timer 
                const dynamicPipeGap = Math.max(150, Math.min(PIPE_GAP, canvas.logicalHeight / 3)); // Ensure gap is reasonable
                const minPipeHeight = 50;
                const maxPipeHeight = canvas.logicalHeight - dynamicPipeGap - minPipeHeight - GROUND_HEIGHT; // Don't let pipes go into ground
                
                // Use seeded random for consistent pipe heights every game
                const pipeHeight = seededRandom() * (maxPipeHeight - minPipeHeight) + minPipeHeight;
                
                pipes.push({
                    x: canvas.logicalWidth,
                    top: pipeHeight,
                    bottom: pipeHeight + dynamicPipeGap,
                    passed: false,
                    isFirstPipe: false
                });
            }

            // Anti-cheat: Track collision state to prevent bypassing
            let collisionDetected = false;
            
            pipes.forEach(pipe => {
                pipe.x -= SPEED * timeScale;

                // Collision detection - CANNOT BE BYPASSED
                const birdLeft = bird.x - bird.width / 2;
                const birdRight = bird.x + bird.width / 2;
                const birdTop = bird.y - bird.height / 2;
                const birdBottom = bird.y + bird.height / 2;

                const pipeRight = pipe.x + PIPE_WIDTH;

                // Multiple collision checks to prevent bypassing
                const horizontalCollision = birdRight > pipe.x && birdLeft < pipeRight;
                const topCollision = birdTop < pipe.top;
                const bottomCollision = birdBottom > pipe.bottom;

                if (horizontalCollision && (topCollision || bottomCollision)) {
                    collisionDetected = true;
                    console.error('üö´ Pipe collision detected!');
                }

                // Score
                if (!pipe.passed && pipe.x < bird.x) {
                    pipe.passed = true;
                    pipesPassed++; // Anti-cheat: Track pipes
                    
                    // Anti-cheat: Verify score matches pipes passed
                    if (score !== pipesPassed - 1) {
                        console.error('üö´ Score tampering detected!');
                        collisionDetected = true;
                    }
                    
                    score++;
                    scoreDisplay.textContent = score;
                    
                    // Create particle effect at score location
                    createScoreParticles(canvas.logicalWidth / 2, 60);
                    
                    // Score pop animation
                    scoreDisplay.style.transform = 'translate(-50%, 0) scale(1.3)';
                    setTimeout(() => {
                        scoreDisplay.style.transform = 'translate(-50%, 0) scale(1)';
                    }, 200);
                }
            });

            // Force end game if collision was detected (cannot be bypassed)
            if (collisionDetected) {
                return endGame();
            }

            // Remove off-screen pipes
            pipes = pipes.filter(pipe => pipe.x + PIPE_WIDTH > 0);

            // Update distance to next pipe
            updateDistance();

            // Update background and particles
            updateBackground();
            updateParticles();
        }

        // --- Distance Calculation ---
        function updateDistance() {
            // Find the next pipe (first pipe that hasn't been passed)
            const nextPipe = pipes.find(pipe => !pipe.passed && pipe.x + PIPE_WIDTH >= bird.x);
            
            if (nextPipe) {
                // Calculate distance from bird to the center of the pipe gap
                const pipeCenter = nextPipe.x + PIPE_WIDTH / 2;
                const distance = Math.max(0, Math.round(pipeCenter - bird.x));
                distanceValue.textContent = distance;
                
                // Change color based on distance (visual warning)
                if (distance < 50) {
                    distanceDisplay.style.color = '#ef4444'; // Red when very close
                    distanceDisplay.style.transform = 'translate(-50%, 0) scale(1.1)';
                } else if (distance < 100) {
                    distanceDisplay.style.color = '#f59e0b'; // Orange when close
                    distanceDisplay.style.transform = 'translate(-50%, 0) scale(1.05)';
                } else {
                    distanceDisplay.style.color = '#06b6d4'; // Cyan when far
                    distanceDisplay.style.transform = 'translate(-50%, 0) scale(1)';
                }
            } else {
                distanceValue.textContent = '0';
            }
        }

        // --- Draw Logic ---
        function draw() {
            const w = canvas.logicalWidth;
            const h = canvas.logicalHeight;

            // Clear any previous shadow settings
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;

            // Draw Sky with gradient
            const skyGradient = ctx.createLinearGradient(0, 0, 0, h);
            skyGradient.addColorStop(0, '#87ceeb'); // Light sky blue at top
            skyGradient.addColorStop(0.7, '#70c5ce'); // Flappy bird sky blue
            skyGradient.addColorStop(1, '#5fb3c1'); // Slightly darker at bottom
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, w, h);

            // Draw Background elements (clouds, ground)
            drawBackground(w, h);

            // Draw Particles (before pipes so they appear behind)
            drawParticles();

            // Draw Pipes
            pipes.forEach(pipe => {
                // Create gradient for pipes
                const pipeGradient = ctx.createLinearGradient(pipe.x, 0, pipe.x + PIPE_WIDTH, 0);
                pipeGradient.addColorStop(0, '#34d399'); // lighter emerald
                pipeGradient.addColorStop(0.3, '#10b981'); // emerald-500
                pipeGradient.addColorStop(0.7, '#059669'); // darker emerald
                pipeGradient.addColorStop(1, '#047857'); // even darker

                // Add shadow behind pipes
                ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
                ctx.shadowBlur = 10;
                ctx.shadowOffsetX = 4;
                ctx.shadowOffsetY = 0;

                // Draw top pipe with gradient
                ctx.fillStyle = pipeGradient;
                ctx.fillRect(pipe.x, 0, PIPE_WIDTH, pipe.top);

                // Draw bottom pipe with gradient
                ctx.fillRect(pipe.x, pipe.bottom, PIPE_WIDTH, h - pipe.bottom - GROUND_HEIGHT);

                // Clear shadow for caps
                ctx.shadowColor = 'transparent';

                // Add caps with gradient
                const capHeight = 25; 
                const capOverlap = 5; 
                
                const capGradient = ctx.createLinearGradient(pipe.x - capOverlap, 0, pipe.x + PIPE_WIDTH + capOverlap, 0);
                capGradient.addColorStop(0, '#6ee7b7'); // very light emerald
                capGradient.addColorStop(0.5, '#10b981'); // emerald-500
                capGradient.addColorStop(1, '#065f46'); // very dark emerald

                // Top pipe cap with shadow
                ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                ctx.shadowBlur = 5;
                ctx.shadowOffsetY = 2;
                ctx.fillStyle = capGradient;
                ctx.fillRect(pipe.x - capOverlap, pipe.top - capHeight, PIPE_WIDTH + capOverlap * 2, capHeight);
                
                // Top cap shine
                ctx.shadowColor = 'transparent';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.fillRect(pipe.x - capOverlap, pipe.top - capHeight, PIPE_WIDTH + capOverlap * 2, capHeight * 0.3);

                // Bottom pipe cap with shadow
                ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                ctx.shadowBlur = 5;
                ctx.shadowOffsetY = 2;
                ctx.fillStyle = capGradient;
                ctx.fillRect(pipe.x - capOverlap, pipe.bottom, PIPE_WIDTH + capOverlap * 2, capHeight);
                
                // Bottom cap shine
                ctx.shadowColor = 'transparent';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.fillRect(pipe.x - capOverlap, pipe.bottom, PIPE_WIDTH + capOverlap * 2, capHeight * 0.3);

                // Add vertical highlight stripe on pipes
                ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
                ctx.fillRect(pipe.x + PIPE_WIDTH * 0.15, 0, PIPE_WIDTH * 0.15, pipe.top);
                ctx.fillRect(pipe.x + PIPE_WIDTH * 0.15, pipe.bottom, PIPE_WIDTH * 0.15, h - pipe.bottom - GROUND_HEIGHT);
            });

            // Draw Bird
            ctx.save();
            ctx.translate(bird.x, bird.y);
            ctx.rotate(bird.rotation);
            
            if (birdImage) {
                // Calculate scale to fit within BIRD_WIDTH/HEIGHT while maintaining aspect ratio
                const aspectRatio = birdImage.width / birdImage.height;
                let drawWidth = BIRD_WIDTH;
                let drawHeight = BIRD_HEIGHT;

                // We want to fit it inside the square bounds
                if (aspectRatio > 1) { // Wide image
                    drawHeight = BIRD_WIDTH / aspectRatio;
                    drawWidth = BIRD_WIDTH;
                } else { // Tall or square image
                    drawWidth = BIRD_HEIGHT * aspectRatio;
                    drawHeight = BIRD_HEIGHT;
                }
                
                // Add drop shadow and glow effect
                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                ctx.shadowBlur = 15;
                ctx.shadowOffsetX = 3;
                ctx.shadowOffsetY = 3;
                
                ctx.drawImage(birdImage, -drawWidth / 2, -drawHeight / 2, drawWidth, drawHeight);
                
                // Add subtle glow
                ctx.shadowColor = 'rgba(255, 255, 255, 0.3)';
                ctx.shadowBlur = 10;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
                ctx.drawImage(birdImage, -drawWidth / 2, -drawHeight / 2, drawWidth, drawHeight);
            } else {
                // Default bird with gradient and shadow
                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                ctx.shadowBlur = 15;
                ctx.shadowOffsetX = 3;
                ctx.shadowOffsetY = 3;
                
                const gradient = ctx.createLinearGradient(-bird.width / 2, -bird.height / 2, bird.width / 2, bird.height / 2);
                gradient.addColorStop(0, '#fbbf24'); // yellow-400
                gradient.addColorStop(1, '#f59e0b'); // yellow-600
                ctx.fillStyle = gradient;
                ctx.fillRect(-bird.width / 2, -bird.height / 2, bird.width, bird.height);
                
                // Add highlight
                ctx.shadowColor = 'transparent';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.fillRect(-bird.width / 2, -bird.height / 2, bird.width / 4, bird.height / 4);
            }
            
            ctx.restore();
        }

        // --- Game State Functions ---
        function flap() {
            if (!gameover) {
                totalFlaps++; // Anti-cheat: Track flaps
                bird.velocity = FLAP_STRENGTH;
                playFlapSound();
                // Create flap particles for visual feedback
                createFlapParticles(bird.x, bird.y);
            }
        }

        function endGame() {
            if (gameover) return; 
            gameover = true;
            playOutSound();
            
            // Create collision explosion effect
            createCollisionParticles(bird.x, bird.y);
            
            // Shake animation on game over
            canvas.style.animation = 'shake 0.5s';
            setTimeout(() => {
                canvas.style.animation = '';
            }, 500);
            
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('flappyHighScore', highScore);
            }
            finalScore.textContent = score;
            highScoreDisplay.textContent = highScore;
            
            // Save score to Firebase
            if (playerName && score > 0) {
                saveScoreToFirebase(playerName, score);
            }
            
            // Animate game over screen appearance
            setTimeout(() => {
                scoreDisplay.classList.add('hidden');
                distanceDisplay.classList.add('hidden');
                playerNameDisplay.classList.add('hidden');
                gameOverScreen.classList.remove('hidden');
                gameOverScreen.classList.add('flex');
                gameOverScreen.style.animation = 'fadeIn 0.5s ease-in';
                
                // Load leaderboard
                loadLeaderboard();
            }, 300);
        }

        function startGame() {
            initAudio();
            Tone.start(); 

            // Stop any lingering sounds
            if (outAudio) {
                outAudio.pause();
                outAudio.currentTime = 0;
            }
            if (outSynth) {
                outSynth.triggerRelease();
            }

            setup();
        }

        // --- Event Listeners ---
        saveNameButton.addEventListener('click', () => {
            const name = playerNameInput.value.trim();
            if (name.length > 0) {
                savePlayerName(name);
                hideNameEntry();
                startScreen.classList.remove('hidden');
            } else {
                alert('Please enter a name!');
            }
        });

        playerNameInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                saveNameButton.click();
            }
        });

        changeNameButton.addEventListener('click', () => {
            gameOverScreen.classList.add('hidden');
            gameOverScreen.classList.remove('flex');
            showNameEntry();
        });

        startButton.addEventListener('click', startGame);
        restartButton.addEventListener('click', startGame);

        canvas.addEventListener('mousedown', flap);
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault(); 
            flap();
        });
        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space' || e.code === 'ArrowUp' || e.key === ' ') {
                e.preventDefault(); // Prevent spacebar from scrolling
                if (startScreen.classList.contains('hidden') && gameOverScreen.classList.contains('hidden')) {
                    flap();
                } else if (!startScreen.classList.contains('hidden')) {
                    startGame();
                } else if (!gameOverScreen.classList.contains('hidden')) {
                    startGame();
                }
            }
        });

        window.addEventListener('resize', () => {
            // Re-setup the canvas and game state on resize
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            canvas.logicalWidth = rect.width;
            canvas.logicalHeight = rect.height;

            if (gameover) {
                // If game is over, just redraw the end screen
                draw(); // Redraw static elements
                drawBackground(canvas.logicalWidth, canvas.logicalHeight);
            } else if (!startScreen.classList.contains('hidden')) {
                // If on start screen, just redraw background
                initialScreenSetup();
            } else {
                // If game is running, restart it to avoid weird scaling issues
                setup();
            }
        });

        function initialScreenSetup() {
            // Set title from config
            document.getElementById('gameTitle').textContent = GAME_TITLE;
            // Load developer-defined assets
            loadDeveloperAssets();

            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            canvas.logicalWidth = rect.width;
            canvas.logicalHeight = rect.height;

            // Draw sky with gradient
            const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.logicalHeight);
            skyGradient.addColorStop(0, '#87ceeb');
            skyGradient.addColorStop(0.7, '#70c5ce');
            skyGradient.addColorStop(1, '#5fb3c1');
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, canvas.logicalWidth, canvas.logicalHeight);
            
            initBackground();
            drawBackground(canvas.logicalWidth, canvas.logicalHeight);

            scoreDisplay.classList.add('hidden');
            distanceDisplay.classList.add('hidden');
            playerNameDisplay.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            gameOverScreen.classList.remove('flex');
            
            // Check if player has a name, otherwise show name entry
            if (playerName) {
                currentPlayerName.textContent = playerName;
                startScreen.classList.remove('hidden');
                startScreen.style.opacity = '1';
                nameEntryScreen.classList.add('hidden');
            } else {
                startScreen.classList.add('hidden');
                showNameEntry();
            }
        }

        initialScreenSetup();

        // --- Admin Controls ---
        // Show clear button when Shift+Click on leaderboard title
        const leaderboardContainer = document.getElementById('leaderboardContainer');
        const clearBtn = document.getElementById('clearLeaderboardBtn');
        let shiftClicks = 0;
        
        leaderboardContainer.addEventListener('click', (e) => {
            if (e.shiftKey) {
                shiftClicks++;
                if (shiftClicks >= 3) {
                    clearBtn.classList.remove('hidden');
                    console.log('üîì Admin mode activated - Clear button visible');
                }
            }
        });

        // Clear button event listener
        clearBtn.addEventListener('click', () => {
            if (confirm('‚ö†Ô∏è Clear entire leaderboard?\n\nThis will remove:\n- All leaderboard scores\n- Your player name\n- Your high score\n\nThis action cannot be undone!')) {
                clearAllData();
                location.reload();
            }
        });
        
        console.log('üéÆ Game Commands Available:');
        console.log('  - clearLeaderboard() : Clear the leaderboard');
        console.log('  - clearAllData() : Clear all game data (leaderboard, name, ID, high score)');
        console.log('');
        console.log('üí° Quick Clear: Hold Shift and click leaderboard 3 times to show clear button');

    </script>
</body>
</html>