<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>My Flappy Aljo</title>
    
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800;900&display=swap" rel="stylesheet">
    
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Load Tone.js for audio -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
    
    <style>
        /* ===== ROOT VARIABLES ===== */
        :root {
            --color-primary: #06b6d4;
            --color-primary-dark: #0891b2;
            --color-accent: #10b981;
            --color-accent-dark: #059669;
            --color-danger: #ef4444;
            --color-warning: #f59e0b;
            --color-surface: rgba(15, 23, 42, 0.85);
            --color-surface-light: rgba(30, 41, 59, 0.9);
            --color-glass: rgba(255, 255, 255, 0.08);
            --color-glass-border: rgba(255, 255, 255, 0.12);
            --radius-lg: 16px;
            --radius-xl: 24px;
            --safe-top: env(safe-area-inset-top, 0px);
            --safe-bottom: env(safe-area-inset-bottom, 0px);
            --safe-left: env(safe-area-inset-left, 0px);
            --safe-right: env(safe-area-inset-right, 0px);
        }

        /* ===== GLOBAL RESET ===== */
        *, *::before, *::after { box-sizing: border-box; }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            margin: 0;
            padding: 0;
            background: #0f172a;
            overflow: hidden;
            position: fixed;
            inset: 0;
        }

        /* ===== CANVAS ===== */
        canvas {
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            touch-action: none;
            display: block;
        }

        /* ===== LAYOUT ===== */
        .game-wrapper {
            display: flex;
            flex-direction: column;
            height: 100vh;
            height: 100dvh; /* dynamic viewport height for mobile */
            width: 100vw;
            overflow: hidden;
            padding-top: var(--safe-top);
            padding-bottom: var(--safe-bottom);
            padding-left: var(--safe-left);
            padding-right: var(--safe-right);
        }

        .game-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0; /* allows flex child to shrink */
            max-height: 100%;
        }

        .canvas-container {
            width: 100%;
            max-width: 100%;
        }

        /* ===== TITLE ===== */
        .game-title {
            font-size: clamp(1.2rem, 4vw, 2.5rem);
            padding: clamp(0.3rem, 1.5vw, 1rem);
            letter-spacing: 0.02em;
            background: linear-gradient(135deg, #67e8f9, #06b6d4, #a78bfa);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            filter: drop-shadow(0 2px 8px rgba(6, 182, 212, 0.35));
            line-height: 1.2;
        }

        /* ===== GLASSMORPHISM CARD ===== */
        .glass-card {
            background: var(--color-surface);
            backdrop-filter: blur(20px) saturate(1.3);
            -webkit-backdrop-filter: blur(20px) saturate(1.3);
            border: 1px solid var(--color-glass-border);
            border-radius: var(--radius-xl);
            box-shadow:
                0 8px 32px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.06);
        }

        /* ===== BUTTONS ===== */
        .btn {
            position: relative;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            font-family: inherit;
            font-weight: 700;
            border: none;
            cursor: pointer;
            border-radius: var(--radius-lg);
            transition: transform 0.2s cubic-bezier(.34,1.56,.64,1), box-shadow 0.25s ease, filter 0.2s ease;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            min-height: 52px;
            padding: 14px 28px;
            font-size: 1.05rem;
            letter-spacing: 0.01em;
        }
        .btn:hover {
            transform: translateY(-2px) scale(1.03);
        }
        .btn:active {
            transform: translateY(1px) scale(0.97);
        }

        .btn-primary {
            background: linear-gradient(135deg, #34d399, #10b981, #059669);
            color: #fff;
            box-shadow: 0 4px 15px rgba(16, 185, 129, 0.4), inset 0 1px 0 rgba(255,255,255,0.2);
        }
        .btn-primary:hover {
            box-shadow: 0 8px 30px rgba(16, 185, 129, 0.55);
            filter: brightness(1.1);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #a78bfa, #8b5cf6, #7c3aed);
            color: #fff;
            box-shadow: 0 4px 15px rgba(139, 92, 246, 0.35), inset 0 1px 0 rgba(255,255,255,0.15);
        }
        .btn-secondary:hover {
            box-shadow: 0 8px 30px rgba(139, 92, 246, 0.5);
            filter: brightness(1.1);
        }

        .btn-accent {
            background: linear-gradient(135deg, #67e8f9, #06b6d4, #0891b2);
            color: #fff;
            box-shadow: 0 4px 15px rgba(6, 182, 212, 0.4), inset 0 1px 0 rgba(255,255,255,0.2);
        }
        .btn-accent:hover {
            box-shadow: 0 8px 30px rgba(6, 182, 212, 0.55);
            filter: brightness(1.1);
        }

        .btn-lg {
            min-height: 60px;
            padding: 16px 32px;
            font-size: 1.15rem;
            border-radius: var(--radius-xl);
        }

        /* ===== OVERLAYS ===== */
        .overlay {
            backdrop-filter: blur(12px) saturate(1.2);
            -webkit-backdrop-filter: blur(12px) saturate(1.2);
        }

        /* ===== INPUT ===== */
        .input-field {
            width: 100%;
            padding: 14px 20px;
            background: rgba(30, 41, 59, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: var(--radius-lg);
            color: #fff;
            font-family: inherit;
            font-size: 1.1rem;
            text-align: center;
            font-weight: 600;
            transition: border-color 0.25s ease, box-shadow 0.25s ease;
            outline: none;
        }
        .input-field::placeholder {
            color: rgba(255,255,255,0.35);
            font-weight: 400;
        }
        .input-field:focus {
            border-color: var(--color-primary);
            box-shadow: 0 0 0 4px rgba(6, 182, 212, 0.2), 0 0 20px rgba(6, 182, 212, 0.1);
        }

        /* ===== LEADERBOARD ENTRY ===== */
        .lb-entry {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 14px;
            border-radius: 12px;
            transition: background 0.2s ease, transform 0.15s ease;
            border: 1px solid transparent;
        }
        .lb-entry:hover {
            background: rgba(255,255,255,0.06);
            transform: translateX(2px);
        }
        .lb-entry.current-player {
            background: linear-gradient(135deg, rgba(6,182,212,0.2), rgba(139,92,246,0.15));
            border-color: rgba(6, 182, 212, 0.4);
            box-shadow: 0 0 15px rgba(6, 182, 212, 0.1);
        }
        .lb-entry .rank {
            font-size: 1.3rem;
            min-width: 36px;
            text-align: center;
        }
        .lb-entry .player-name {
            font-weight: 600;
            color: #e2e8f0;
            font-size: 0.95rem;
        }
        .lb-entry .player-score {
            font-weight: 800;
            color: #fbbf24;
            font-size: 1.15rem;
            font-variant-numeric: tabular-nums;
        }
        .lb-entry .online-dot {
            font-size: 0.6rem;
            line-height: 1;
        }

        /* ===== SCORE DISPLAY ===== */
        .score-hud {
            font-variant-numeric: tabular-nums;
            text-shadow: 0 2px 10px rgba(0,0,0,0.6), 0 0 30px rgba(0,0,0,0.3);
            letter-spacing: 0.02em;
        }

        /* ===== BADGE (online indicator) ===== */
        .online-badge {
            background: rgba(0, 0, 0, 0.55);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 999px;
            padding: 6px 12px;
            font-size: 0.75rem;
        }
        .online-badge .pulse-dot {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #34d399;
            animation: pulseDot 2s ease-in-out infinite;
            box-shadow: 0 0 6px rgba(52, 211, 153, 0.6);
        }

        .player-badge {
            background: rgba(0, 0, 0, 0.45);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 999px;
            padding: 6px 14px;
            font-size: 0.8rem;
        }

        /* ===== NEW HIGH SCORE ===== */
        @keyframes newHighScore {
            0% { transform: scale(1); text-shadow: 0 0 10px rgba(251,191,36,0.5); }
            50% { transform: scale(1.08); text-shadow: 0 0 30px rgba(251,191,36,0.8), 0 0 60px rgba(251,191,36,0.3); }
            100% { transform: scale(1); text-shadow: 0 0 10px rgba(251,191,36,0.5); }
        }
        .new-high-score {
            animation: newHighScore 1.5s ease-in-out infinite;
        }

        /* ===== GAME OVER SCROLL ===== */
        .game-over-scroll {
            overflow-y: auto;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: thin;
            scrollbar-color: rgba(6,182,212,0.4) transparent;
            padding-bottom: calc(20px + var(--safe-bottom));
        }
        .game-over-scroll::-webkit-scrollbar {
            width: 6px;
        }
        .game-over-scroll::-webkit-scrollbar-track {
            background: transparent;
        }
        .game-over-scroll::-webkit-scrollbar-thumb {
            background: rgba(6, 182, 212, 0.3);
            border-radius: 10px;
        }

        /* ===== ANIMATIONS ===== */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideUp {
            from { transform: translateY(30px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        @keyframes slideDown {
            from { transform: translateY(-40px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        @keyframes scaleIn {
            from { transform: scale(0.85); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            20% { transform: translateX(-8px); }
            40% { transform: translateX(8px); }
            60% { transform: translateX(-5px); }
            80% { transform: translateX(5px); }
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-12px); }
        }

        @keyframes pulseDot {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(0.8); }
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-6px); }
        }

        .animate-fadeIn { animation: fadeIn 0.4s ease-out; }
        .animate-slideDown { animation: slideDown 0.5s cubic-bezier(.34,1.56,.64,1); }
        .animate-slideUp { animation: slideUp 0.5s cubic-bezier(.34,1.56,.64,1); }
        .animate-scaleIn { animation: scaleIn 0.4s cubic-bezier(.34,1.56,.64,1); }
        .animate-pulse { animation: pulse 2.5s ease-in-out infinite; }
        .animate-bounce { animation: bounce 1.2s ease-in-out infinite; }
        .animate-float { animation: float 3s ease-in-out infinite; }

        /* Stagger animations */
        .stagger-1 { animation-delay: 0.1s; animation-fill-mode: both; }
        .stagger-2 { animation-delay: 0.2s; animation-fill-mode: both; }
        .stagger-3 { animation-delay: 0.35s; animation-fill-mode: both; }
        .stagger-4 { animation-delay: 0.5s; animation-fill-mode: both; }
        .stagger-5 { animation-delay: 0.65s; animation-fill-mode: both; }

        /* ===== CUSTOM SCROLLBAR (leaderboard) ===== */
        .custom-scrollbar::-webkit-scrollbar { width: 6px; }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, #06b6d4, #8b5cf6);
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(180deg, #22d3ee, #a78bfa);
        }

        /* ===== RESPONSIVE ===== */
        @media (max-width: 480px) {
            .game-title { font-size: 1.1rem; padding: 0.25rem; }
            .btn { min-height: 48px; padding: 12px 20px; font-size: 0.95rem; }
            .btn-lg { min-height: 54px; padding: 14px 24px; font-size: 1.05rem; }
            .glass-card { border-radius: 16px; }
            .lb-entry { padding: 8px 10px; }
            .lb-entry .rank { font-size: 1.1rem; min-width: 30px; }
            .lb-entry .player-name { font-size: 0.85rem; }
            .lb-entry .player-score { font-size: 1rem; }
            .score-card-score { font-size: 3.5rem !important; }
        }

        @media (min-width: 481px) and (max-width: 767px) {
            .game-title { font-size: 1.4rem; padding: 0.4rem; }
            .score-card-score { font-size: 4rem !important; }
        }

        @media (min-width: 768px) {
            .game-title { font-size: 2.2rem; padding: 0.7rem; }
        }

        @media (min-width: 1024px) {
            .game-title { font-size: 2.5rem; padding: 0.8rem; }
        }

        /* ===== LANDSCAPE MOBILE ===== */
        @media (max-height: 500px) and (orientation: landscape) {
            .game-title { font-size: 1rem; padding: 0.15rem; }
            .btn { min-height: 40px; padding: 8px 16px; font-size: 0.85rem; }
            .btn-lg { min-height: 44px; padding: 10px 20px; font-size: 0.95rem; }
        }

        /* ===== SELECTION ===== */
        ::selection {
            background: rgba(6, 182, 212, 0.3);
            color: #fff;
        }
    </style>
</head>
<body class="bg-gray-900 text-white">

    <div class="game-wrapper">
        <!-- Game Title -->
        <h1 id="gameTitle" class="game-title font-extrabold text-center flex-shrink-0 animate-slideDown" style="margin:0;">
            My Flappy Aljo
        </h1>
        
        <!-- Game container -->
        <div class="game-container">
            <div class="canvas-container bg-gray-800 overflow-hidden relative mx-auto" style="flex: 1; display: flex; flex-direction: column; border-radius: 0;">
                <canvas id="gameCanvas" class="w-full h-full"></canvas>
            
            <!-- Start Screen Overlay -->
            <div id="startScreen" class="overlay absolute inset-0 bg-black/60 flex flex-col items-center justify-center p-4 z-10 animate-fadeIn">
                <div class="text-center animate-float">
                    <h2 class="text-3xl md:text-5xl font-extrabold mb-3 text-white" style="text-shadow: 0 2px 15px rgba(0,0,0,0.5);">Ready?</h2>
                    <p class="text-sm md:text-base mb-8 text-gray-300">Click, tap, or press SPACE to flap!</p>
                </div>
                <button id="startButton" class="btn btn-primary btn-lg animate-pulse">
                    üöÄ Start Game
                </button>
            </div>

            <!-- Name Entry Screen -->
            <div id="nameEntryScreen" class="overlay absolute inset-0 bg-black/85 flex flex-col items-center justify-center p-4 z-20">
                <div class="glass-card p-6 md:p-8 max-w-sm w-full mx-4 animate-scaleIn">
                    <div class="text-center mb-6">
                        <span class="text-4xl mb-2 block">üéÆ</span>
                        <h2 class="text-2xl md:text-3xl font-extrabold bg-gradient-to-r from-cyan-300 to-violet-400 bg-clip-text text-transparent mb-2">Welcome!</h2>
                        <p class="text-gray-400 text-sm">Enter your name to start playing</p>
                    </div>
                    <input type="text" id="playerNameInput" maxlength="20" placeholder="Your Name" 
                           class="input-field mb-4">
                    <button id="saveNameButton" class="btn btn-accent btn-lg w-full">
                        ‚úÖ Start Playing
                    </button>
                </div>
            </div>

            <!-- Game Over Overlay -->
            <div id="gameOverScreen" class="overlay absolute inset-0 bg-black/85 hidden flex-col items-center z-10">
                <div class="game-over-scroll flex flex-col items-center w-full h-full px-3 md:px-4 py-4">
                    <div class="flex flex-col items-center w-full max-w-lg">

                    <!-- Game Over Title -->
                    <h2 class="text-2xl sm:text-3xl md:text-4xl font-extrabold text-red-400 mb-4 animate-slideDown text-center" style="text-shadow: 0 0 20px rgba(239,68,68,0.4);">
                        üí• You Killed Aljo!
                    </h2>
                    
                    <!-- Score Card -->
                    <div class="glass-card p-5 md:p-6 mb-4 w-full animate-scaleIn stagger-1">
                        <div class="text-center mb-3">
                            <p class="text-gray-400 text-xs uppercase tracking-widest mb-1">Your Score</p>
                            <p class="score-card-score text-5xl md:text-6xl font-black text-yellow-400" style="line-height:1.1;">
                                <span id="finalScore">0</span>
                            </p>
                        </div>
                        <div class="flex justify-center items-center pt-3 border-t border-white/10">
                            <div class="text-center">
                                <p class="text-gray-500 text-xs uppercase tracking-wider mb-0.5">Personal Best</p>
                                <p class="text-xl md:text-2xl font-bold text-cyan-400">
                                    <span id="highScore">0</span> üèÜ
                                </p>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Play Again Button -->
                    <button id="restartButton" class="btn btn-primary btn-lg w-full mb-4 animate-slideUp stagger-2">
                        üîÑ Play Again
                    </button>
                    
                    <!-- Leaderboard -->
                    <div id="leaderboardContainer" class="glass-card p-4 md:p-5 mb-4 w-full animate-slideUp stagger-3">
                        <div class="flex items-center justify-between mb-3">
                            <h3 class="text-lg md:text-xl font-bold bg-gradient-to-r from-cyan-300 to-yellow-300 bg-clip-text text-transparent flex-1 text-center">
                                üèÜ Global Leaderboard
                            </h3>
                            <button id="clearLeaderboardBtn" class="hidden text-xs bg-red-600/80 hover:bg-red-600 text-white px-2 py-1 rounded-lg transition">
                                üóëÔ∏è
                            </button>
                        </div>
                        <div id="leaderboardList" class="space-y-1.5 max-h-64 md:max-h-80 overflow-y-auto pr-1 custom-scrollbar">
                            <!-- Leaderboard entries will be inserted here -->
                        </div>
                    </div>
                    
                    <!-- Change Name Button -->
                    <button id="changeNameButton" class="btn btn-secondary w-full animate-slideUp stagger-4">
                        ‚úèÔ∏è Change Name
                    </button>

                    </div>
                </div>
            </div>

            <!-- Score Display -->
            <div id="scoreDisplay" class="score-hud absolute top-3 left-1/2 -translate-x-1/2 text-4xl md:text-6xl font-black text-white z-[5]" style="transition: transform 0.2s ease-out;">
                0
            </div>
            
            <!-- Player Name Display -->
            <div id="playerNameDisplay" class="player-badge absolute bottom-3 left-3 font-semibold text-white hidden">
                üë§ <span id="currentPlayerName"></span>
            </div>
            
            <!-- Active Players Display -->
            <div id="activePlayersDisplay" class="online-badge absolute top-3 right-3 font-semibold text-white">
                <div class="flex items-center gap-1.5">
                    <span class="pulse-dot"></span>
                    <span id="activePlayersCount">0</span> online
                </div>
            </div>
            </div>
        </div>
    </div>

    <script>
        // --- FIREBASE CONFIGURATION ---
        
        // Replace these with your Firebase project credentials
        // Get your config from: https://console.firebase.google.com/
        // Import the functions you need from the SDKs you need

        const firebaseConfig = {
        apiKey: "AIzaSyD-qDhqI3MTJf2eqGsKXae29luSg8UBP1Q",
        authDomain: "my-flappy-aljo.firebaseapp.com",
        databaseURL: "https://my-flappy-aljo-default-rtdb.firebaseio.com",
        projectId: "my-flappy-aljo",
        storageBucket: "my-flappy-aljo.firebasestorage.app",
        messagingSenderId: "941796846018",
        appId: "1:941796846018:web:b8a66260dfff2f80f10e5b"
        };


        
        // Check if Firebase is configured
        const isFirebaseConfigured = firebaseConfig.apiKey !== "YOUR_API_KEY";
        
        // Initialize Firebase
        let database = null;
        let useLocalLeaderboard = true;
        let presenceRef = null; // Reference to current player's presence
        let activePlayersRef = null; // Reference to active players list
        
        if (isFirebaseConfigured && typeof firebase !== 'undefined') {
            try {
                firebase.initializeApp(firebaseConfig);
                database = firebase.database();
                useLocalLeaderboard = false;
                console.log("‚úÖ Firebase initialized successfully");
            } catch (error) {
                console.error("‚ùå Firebase initialization error:", error);
                console.log("üìù Using local leaderboard instead");
                useLocalLeaderboard = true;
            }
        } else {
            console.log("‚ö†Ô∏è Firebase not configured. Using local leaderboard.");
            console.log("üí° To enable online leaderboard, see FIREBASE_SETUP.md");
            useLocalLeaderboard = true;
        }
        
        // --- GLOBAL FUNCTIONS (Define early for console access) ---
        window.clearLeaderboard = function() {
            localStorage.removeItem('flappyLocalLeaderboard');
            console.log('‚úÖ Local leaderboard cleared!');
            
            // Also clear Firebase if connected
            if (database && !useLocalLeaderboard) {
                database.ref('leaderboard').remove()
                    .then(() => {
                        console.log('‚òÅÔ∏è Firebase leaderboard cleared!');
                        alert('‚úÖ Leaderboard cleared (Local + Firebase)! Refresh the page.');
                    })
                    .catch(err => {
                        console.error('‚ùå Error clearing Firebase:', err);
                        alert('‚úÖ Local leaderboard cleared! Refresh the page.');
                    });
            } else {
                alert('‚úÖ Local leaderboard cleared! Refresh the page.');
            }
        };
        
        window.clearAllData = function() {
            // Clear localStorage
            localStorage.removeItem('flappyLocalLeaderboard');
            localStorage.removeItem('flappyPlayerName');
            localStorage.removeItem('flappyPlayerId');
            localStorage.removeItem('flappyHighScore');
            console.log('üóëÔ∏è Local data cleared!');
            
            // Clear Firebase if connected
            if (database && !useLocalLeaderboard) {
                database.ref('leaderboard').remove()
                    .then(() => {
                        console.log('‚òÅÔ∏è Firebase leaderboard cleared!');
                        alert('‚úÖ All data cleared (Local + Firebase)! The page will reload.');
                        return true;
                    })
                    .catch(err => {
                        console.error('‚ùå Error clearing Firebase:', err);
                        alert('‚ö†Ô∏è Local data cleared, but Firebase error. Check console. Refreshing...');
                        return false;
                    });
            } else {
                alert('‚úÖ All local data cleared! The page will reload.');
            }
        };
        
        // --- DEVELOPER CONFIGURATION ---
        // Change the game title here
        const GAME_TITLE = "My Flappy Aljo"; 
        
        // Paths to your assets. Use "" for default bird/sounds.
        // Recommended: Use relative paths (e.g., "assets/bird.png")
        const BIRD_IMAGE_PATH = "./Tools/face-remo.png";
        const BIRD_PASS_IMAGE_PATH = "./Tools/dominic.jpeg";  // e.g., "./Tools/bird-happy.png" - Bird image shown briefly when passing through pipes
        const BIRD_HIT_IMAGE_PATH = "./Tools/game_over_bird.jpeg";  // e.g., "./Tools/bird-hurt.png" - Bird image shown when hitting a pipe
        const FLAP_SOUND_PATH = "./Tools/falp SOund Final.mp3"; // e.g., "audio/my-flap.wav"
        const OUT_SOUND_PATH = "./Tools/out-Fina.mp3";  // e.g., "audio/my-out.mp3"
        const PASS_SOUND_PATH = "./Tools/sucess_sound.mp3";  // e.g., "audio/pass.mp3" - Sound when passing through a pipe
        
        // Game Difficulty Settings
        const PIPE_GAP = 250; // Gap between top and bottom pipes (smaller = harder)
        const PIPE_SPACING = 440; // Distance between pipes (frames at 60fps: 240 = 4 seconds, 180 = 3 seconds, 120 = 2 seconds)
        // --- END CONFIGURATION ---


        // --- DOM Elements ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        const nameEntryScreen = document.getElementById('nameEntryScreen');
        const playerNameInput = document.getElementById('playerNameInput');
        const saveNameButton = document.getElementById('saveNameButton');
        const changeNameButton = document.getElementById('changeNameButton');
        
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const startButton = document.getElementById('startButton');
        const restartButton = document.getElementById('restartButton');
        
        const scoreDisplay = document.getElementById('scoreDisplay');
        const finalScore = document.getElementById('finalScore');
        const highScoreDisplay = document.getElementById('highScore');
        const playerNameDisplay = document.getElementById('playerNameDisplay');
        const currentPlayerName = document.getElementById('currentPlayerName');
        const leaderboardList = document.getElementById('leaderboardList');

        // --- Game Constants ---
        const BIRD_WIDTH = 90; // "very big" and square
        const BIRD_HEIGHT = 90; // "very big" and square
        const PIPE_WIDTH = 100;
        // PIPE_GAP is now configured in the DEVELOPER CONFIGURATION section above
        const GRAVITY = 0.25; 
        const FLAP_STRENGTH = -7.5; 
        const SPEED = 2.9; 
        const GROUND_HEIGHT = 100;
        const CLOUD_SPEED = 0.5;

        // --- Game State ---
        let bird, pipes, score, highScore, gameover, frame;
        let lastTime = 0; // For delta time calculation
        let deltaTime = 0; // Time since last frame
        let timeSinceLastPipe = 0; // Accumulated time for pipe spawning
        
        // Anti-cheat: Track game integrity
        let gameStartTime = 0;
        let pipesPassed = 0;
        let totalFlaps = 0;
        let gameHash = '';
        
        // Simple hash function for integrity checking
        function simpleHash(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32bit integer
            }
            return Math.abs(hash).toString(36);
        }
        
        // Validate score integrity
        function validateScore(score, time, pipes, flaps) {
            // Score should match pipes passed EXACTLY
            if (score !== pipes) {
                console.error('üö´ Score mismatch:', {score, pipes});
                return false;
            }
            
            // Minimum time validation (2 seconds per pipe minimum)
            const minTimeNeeded = pipes * 2;
            if (time < minTimeNeeded) {
                console.error('üö´ Time too fast:', {time, minTimeNeeded});
                return false;
            }
            
            // Maximum time validation (30 seconds max per pipe)
            const maxTimeAllowed = pipes * 30;
            if (time > maxTimeAllowed) {
                console.error('üö´ Time too slow:', {time, maxTimeAllowed});
                return false;
            }
            
            // Flap validation (min 1, max 5 per pipe on average + 10 for start)
            const minFlapsNeeded = pipes * 1;
            const maxReasonableFlaps = pipes * 5 + 10;
            if (flaps < minFlapsNeeded || flaps > maxReasonableFlaps) {
                console.error('üö´ Flap count suspicious:', {flaps, min: minFlapsNeeded, max: maxReasonableFlaps});
                return false;
            }
            
            // Score bounds check
            if (score < 0 || score > 9999) {
                console.error('üö´ Score out of bounds:', score);
                return false;
            }
            
            // Physics validation - bird velocity should be reasonable
            if (typeof bird !== 'undefined' && Math.abs(bird.velocity) > 50) {
                console.error('üö´ Impossible velocity:', bird.velocity);
                return false;
            }
            
            return true;
        }
        
        // --- Player State ---
        let playerName = localStorage.getItem('flappyPlayerName') || '';
        let playerId = localStorage.getItem('flappyPlayerId') || generatePlayerId();
        
        // --- Local Leaderboard (fallback when Firebase is not configured) ---
        function getLocalLeaderboard() {
            const saved = localStorage.getItem('flappyLocalLeaderboard');
            return saved ? JSON.parse(saved) : [];
        }
        
        function saveToLocalLeaderboard(playerName, score) {
            // Anti-cheat: Re-validate before local save
            const gameTime = (Date.now() - gameStartTime) / 1000;
            if (!validateScore(score, gameTime, pipesPassed, totalFlaps)) {
                console.error('üö´ Invalid score - local save rejected');
                return;
            }
            
            let leaderboard = getLocalLeaderboard();
            
            // Find if player name already exists (check by name, not ID for global competition)
            const existingPlayerIndex = leaderboard.findIndex(entry => 
                entry.playerName.toLowerCase() === playerName.toLowerCase()
            );
            
            if (existingPlayerIndex !== -1) {
                // Player name exists - only update if new score is higher
                if (score > leaderboard[existingPlayerIndex].score) {
                    console.log(`üéâ ${playerName}: New high score! ${leaderboard[existingPlayerIndex].score} ‚Üí ${score}`);
                    leaderboard[existingPlayerIndex].score = score;
                    leaderboard[existingPlayerIndex].playerId = playerId;
                    leaderboard[existingPlayerIndex].timestamp = Date.now();
                } else {
                    console.log(`${playerName}: Score ${score} not better than best ${leaderboard[existingPlayerIndex].score}`);
                    return; // Don't save if not a personal best
                }
            } else {
                // New player name - add to leaderboard
                console.log(`üÜï New player: ${playerName} with score ${score}`);
                leaderboard.push({
                    playerName: playerName,
                    score: score,
                    playerId: playerId,
                    timestamp: Date.now()
                });
            }
            
            // Sort by score descending and keep only top 100
            leaderboard.sort((a, b) => b.score - a.score);
            const top100 = leaderboard.slice(0, 100);
            
            localStorage.setItem('flappyLocalLeaderboard', JSON.stringify(top100));
        }
        
        function clearLocalLeaderboard() {
            localStorage.removeItem('flappyLocalLeaderboard');
            console.log('üóëÔ∏è Local leaderboard cleared');
        }
        
        // --- Background State ---
        let groundOffset, clouds;
        
        // --- Particle Effects ---
        let particles = [];
        
        // --- Seeded Random for Consistent Levels ---
        let seed = 12345; // Fixed seed for consistent pipe generation
        
        function seededRandom() {
            // Linear congruential generator for predictable randomness
            seed = (seed * 1664525 + 1013904223) % 4294967296;
            return seed / 4294967296;
        }

        // --- Active Players Tracking ---
        function setupPresence() {
            if (useLocalLeaderboard || !database) {
                console.log('üì° Active players tracking: Using local mode (no Firebase)');
                document.getElementById('activePlayersCount').textContent = '1';
                return;
            }
            
            try {
                // Create presence reference for this player
                presenceRef = database.ref('presence/' + playerId);
                activePlayersRef = database.ref('presence');
                
                // Set player as online
                const presenceData = {
                    playerName: playerName,
                    playerId: playerId,
                    lastActive: firebase.database.ServerValue.TIMESTAMP,
                    status: 'online'
                };
                
                presenceRef.set(presenceData);
                
                // Update last active every 30 seconds
                const updateInterval = setInterval(() => {
                    if (presenceRef) {
                        presenceRef.update({
                            lastActive: firebase.database.ServerValue.TIMESTAMP
                        });
                    }
                }, 30000);
                
                // Set up automatic cleanup on disconnect
                presenceRef.onDisconnect().remove();
                
                // Listen for active players count
                activePlayersRef.on('value', (snapshot) => {
                    const now = Date.now();
                    let activeCount = 0;
                    
                    snapshot.forEach((childSnapshot) => {
                        const data = childSnapshot.val();
                        // Consider active if last active within 2 minutes
                        if (now - data.lastActive < 120000) {
                            activeCount++;
                        }
                    });
                    
                    document.getElementById('activePlayersCount').textContent = activeCount;
                    console.log(`üì° Active players: ${activeCount}`);
                });
                
                // Clean up on page unload
                window.addEventListener('beforeunload', () => {
                    if (presenceRef) {
                        presenceRef.remove();
                    }
                    clearInterval(updateInterval);
                });
                
                console.log('‚úÖ Active players tracking enabled');
            } catch (error) {
                console.error('‚ùå Error setting up presence:', error);
                document.getElementById('activePlayersCount').textContent = '?';
            }
        }
        
        function updatePresenceStatus(status) {
            if (presenceRef && !useLocalLeaderboard) {
                presenceRef.update({
                    status: status,
                    lastActive: firebase.database.ServerValue.TIMESTAMP
                });
            }
        }
        
        // Get list of active players
        async function getActivePlayers() {
            if (useLocalLeaderboard || !database) {
                return [{playerName: playerName, status: 'online'}];
            }
            
            try {
                const snapshot = await database.ref('presence').once('value');
                const players = [];
                const now = Date.now();
                
                snapshot.forEach((childSnapshot) => {
                    const data = childSnapshot.val();
                    // Only include players active within last 2 minutes
                    if (now - data.lastActive < 120000) {
                        players.push({
                            playerName: data.playerName,
                            playerId: data.playerId,
                            status: data.status,
                            lastActive: new Date(data.lastActive).toLocaleTimeString()
                        });
                    }
                });
                
                return players;
            } catch (error) {
                console.error('Error getting active players:', error);
                return [];
            }
        }
        
        // View active players in console
        window.viewActivePlayers = async function() {
            const players = await getActivePlayers();
            console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
            console.log('üü¢ ACTIVE PLAYERS');
            console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
            if (players.length === 0) {
                console.log('No active players');
            } else {
                players.forEach((player, idx) => {
                    console.log(`${idx + 1}. ${player.playerName} - ${player.status} (Last: ${player.lastActive})`);
                });
            }
            console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
            console.log(`Total: ${players.length} player(s) online`);
        };
        
        // --- Player Management ---
        function generatePlayerId() {
            const id = 'player_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            localStorage.setItem('flappyPlayerId', id);
            return id;
        }

        function savePlayerName(name) {
            playerName = name.trim();
            localStorage.setItem('flappyPlayerName', playerName);
            currentPlayerName.textContent = playerName;
            
            // Set up presence tracking
            setupPresence();
        }

        function showNameEntry() {
            nameEntryScreen.classList.remove('hidden');
            nameEntryScreen.style.display = 'flex';
            playerNameInput.value = playerName;
            playerNameInput.focus();
        }

        function hideNameEntry() {
            nameEntryScreen.classList.add('hidden');
            nameEntryScreen.style.display = 'none';
        }

        // --- Firebase Functions ---
        async function saveScoreToFirebase(playerName, score) {
            // Anti-cheat: Validate score before saving
            const gameTime = (Date.now() - gameStartTime) / 1000; // seconds
            const isValid = validateScore(score, gameTime, pipesPassed, totalFlaps);
            
            if (!isValid) {
                console.error('üö´ Invalid score detected! Score rejected.');
                console.log('Debug:', {score, gameTime, pipesPassed, totalFlaps});
                return; // Don't save tampered scores
            }
            
            // Generate integrity hash
            const integrityCheck = simpleHash(
                gameHash + score + pipesPassed + totalFlaps + gameTime.toFixed(2)
            );
            
            console.log('‚úÖ Score validated:', {score, time: gameTime.toFixed(1), pipes: pipesPassed, flaps: totalFlaps, hash: integrityCheck});
            
            // Use local leaderboard if Firebase is not configured
            if (useLocalLeaderboard) {
                console.log("üíæ Saving score to local leaderboard:", {playerName, score});
                saveToLocalLeaderboard(playerName, score);
                return;
            }
            
            if (!database) {
                console.log("Database not initialized, using local leaderboard");
                saveToLocalLeaderboard(playerName, score);
                return;
            }
            
            try {
                // Create a unique key based on player name (case-insensitive)
                const playerKey = playerName.toLowerCase().replace(/[^a-z0-9]/g, '_');
                const leaderboardRef = database.ref('leaderboard/' + playerKey);
                
                // Check if this player name already exists
                const snapshot = await leaderboardRef.once('value');
                const existingData = snapshot.val();
                const currentBest = existingData ? existingData.score : 0;
                
                // Only save if this is a new high score for this player name
                if (score > currentBest) {
                    const timestamp = Date.now();
                    const scoreData = {
                        playerName: playerName, // Keep original capitalization
                        score: score,
                        timestamp: timestamp,
                        playerId: playerId
                    };
                    
                    console.log(`‚òÅÔ∏è ${playerName}: New high score! ${currentBest} ‚Üí ${score}`);
                    
                    // Save to leaderboard (one entry per unique player name)
                    await leaderboardRef.set(scoreData);
                    console.log("‚úÖ Leaderboard updated in Firebase");
                } else {
                    console.log(`${playerName}: Score ${score} not better than best ${currentBest}`);
                }
            } catch (error) {
                console.error("‚ùå Error saving score to Firebase:", error);
                console.log("üíæ Falling back to local leaderboard");
                saveToLocalLeaderboard(playerName, score);
            }
        }

        async function loadLeaderboard() {
            try {
                // Show loading message
                leaderboardList.innerHTML = '<p class="text-gray-400 text-center">Loading leaderboard...</p>';
                
                let scores = [];
                let activePlayerIds = new Set();
                
                // Get active players from presence
                if (!useLocalLeaderboard && database) {
                    try {
                        const presenceSnapshot = await database.ref('presence').once('value');
                        const now = Date.now();
                        presenceSnapshot.forEach((childSnapshot) => {
                            const data = childSnapshot.val();
                            // Consider active if within last 2 minutes
                            if (data && data.playerId && (now - data.lastActive < 120000)) {
                                activePlayerIds.add(data.playerId);
                            }
                        });
                    } catch (err) {
                        console.warn('‚ö†Ô∏è Could not fetch presence data:', err);
                    }
                }
                
                // Load from local or Firebase
                if (useLocalLeaderboard) {
                    console.log("üìÇ Loading from local leaderboard");
                    scores = getLocalLeaderboard();
                    
                    // Add info message
                    const infoDiv = document.createElement('div');
                    infoDiv.className = 'text-xs text-gray-500 text-center mb-2 py-2 px-3 rounded-lg';
                    infoDiv.style.background = 'rgba(255,255,255,0.04)';
                    infoDiv.innerHTML = 'üíæ Local Leaderboard';
                    leaderboardList.innerHTML = '';
                    leaderboardList.appendChild(infoDiv);
                } else if (database) {
                    console.log("‚òÅÔ∏è Loading from Firebase");
                    
                    // Fetch all leaderboard data from Firebase
                    const snapshot = await database.ref('leaderboard').once('value');
                    
                    // Extract all scores
                    snapshot.forEach(childSnapshot => {
                        const data = childSnapshot.val();
                        if (data && data.playerName && typeof data.score === 'number') {
                            scores.push({
                                playerName: data.playerName,
                                score: data.score,
                                playerId: data.playerId,
                                timestamp: data.timestamp || 0,
                                isOnline: activePlayerIds.has(data.playerId)
                            });
                        }
                    });
                }
                
                console.log("üìä Loaded scores:", scores);
                
                // Sort by score in descending order (highest first)
                scores.sort((a, b) => {
                    if (b.score !== a.score) {
                        return b.score - a.score; // Higher score first
                    }
                    return a.timestamp - b.timestamp; // Earlier timestamp if same score
                });
                
                // Display all scores (not just top 10)
                const topScores = scores; // Show all players
                
                // Display leaderboard entries
                if (topScores.length === 0) {
                    const emptyMsg = document.createElement('p');
                    emptyMsg.className = 'text-gray-500 text-center text-sm py-4';
                    emptyMsg.textContent = 'No scores yet. Be the first! üéÆ';
                    leaderboardList.appendChild(emptyMsg);
                } else {
                    topScores.forEach((scoreData, index) => {
                        const rank = index + 1;
                        const isCurrentPlayer = scoreData.playerId === playerId;
                        const medal = rank === 1 ? 'ü•á' : rank === 2 ? 'ü•à' : rank === 3 ? 'ü•â' : `<span style="color:#94a3b8;font-weight:700;font-size:0.85rem;">${rank}</span>`;
                        const onlineIndicator = scoreData.isOnline 
                            ? '<span class="online-dot text-green-400" title="Online">‚óè</span>' 
                            : '<span class="online-dot text-gray-600" title="Offline">‚óè</span>';
                        
                        const entry = document.createElement('div');
                        entry.className = `lb-entry ${isCurrentPlayer ? 'current-player' : ''}`;
                        entry.innerHTML = `
                            <div class="flex items-center gap-2 min-w-0">
                                <span class="rank">${medal}</span>
                                <span class="player-name truncate">${scoreData.playerName}</span>
                                ${onlineIndicator}
                            </div>
                            <span class="player-score">${scoreData.score}</span>
                        `;
                        leaderboardList.appendChild(entry);
                    });
                }
            } catch (error) {
                console.error("‚ùå Error loading leaderboard:", error);
                leaderboardList.innerHTML = `<p class="text-red-400 text-center text-sm">Error: ${error.message}</p>`;
            }
        }

        // --- Custom Assets ---
        let birdImage = null;
        let birdPassImage = null; // Alternative bird image when passing pipes
        let birdHitImage = null; // Alternative bird image when hitting pipes
        let flapAudio = null;
        let outAudio = null;
        let passAudio = null;
        let showPassImage = false; // Flag to show pass image temporarily
        let showHitImage = false; // Flag to show hit image when collision occurs

        // --- Default Synths (Tone.js) ---
        let flapSynth, outSynth, passSynth;

        function initAudio() {
            if (!flapSynth) {
                flapSynth = new Tone.Synth({
                    oscillator: { type: 'sine' },
                    envelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.1 }
                }).toDestination();
                flapSynth.volume.value = 5; // Louder
            }
            if (!outSynth) {
                outSynth = new Tone.NoiseSynth({
                    noise: { type: 'white' },
                    envelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.1 }
                }).toDestination();
                outSynth.volume.value = 5; // Louder
            }
            if (!passSynth) {
                passSynth = new Tone.Synth({
                    oscillator: { type: 'triangle' },
                    envelope: { attack: 0.005, decay: 0.1, sustain: 0, release: 0.1 }
                }).toDestination();
                passSynth.volume.value = -5; // Softer than flap
            }
        }

        // --- Asset Handlers ---
        function loadDeveloperAssets() {
            if (BIRD_IMAGE_PATH) {
                birdImage = new Image();
                birdImage.src = BIRD_IMAGE_PATH;
            }
            if (BIRD_PASS_IMAGE_PATH) {
                birdPassImage = new Image();
                birdPassImage.src = BIRD_PASS_IMAGE_PATH;
            }
            if (BIRD_HIT_IMAGE_PATH) {
                birdHitImage = new Image();
                birdHitImage.src = BIRD_HIT_IMAGE_PATH;
            }
            if (FLAP_SOUND_PATH) {
                flapAudio = new Audio(FLAP_SOUND_PATH);
            }
            if (OUT_SOUND_PATH) {
                outAudio = new Audio(OUT_SOUND_PATH);
            }
            if (PASS_SOUND_PATH) {
                passAudio = new Audio(PASS_SOUND_PATH);
            }
        }

        // --- Sound Players ---
        function playFlapSound() {
            if (Tone.context.state !== 'running') {
                Tone.start();
            }
            if (flapAudio) {
                flapAudio.currentTime = 0; 
                flapAudio.play().catch(e => console.error("Error playing flap sound:", e));
            } else {
                initAudio(); 
                flapSynth.triggerRelease();
                flapSynth.triggerAttackRelease("C5", "8n", Tone.now()); 
            }
        }

        function playOutSound() {
            if (outAudio) {
                outAudio.currentTime = 0;
                outAudio.play().catch(e => console.error("Error playing out sound:", e));
            } else {
                initAudio(); 
                outSynth.triggerRelease();
                outSynth.triggerAttackRelease("4n", Tone.now());
            }
        }

        function playPassSound() {
            if (Tone.context.state !== 'running') {
                Tone.start();
            }
            if (passAudio) {
                passAudio.currentTime = 0;
                passAudio.play().catch(e => console.error("Error playing pass sound:", e));
            } else {
                initAudio();
                passSynth.triggerRelease();
                passSynth.triggerAttackRelease("E5", "8n", Tone.now()); // Pleasant tone when passing pipe
            }
        }

        // --- Particle Functions ---
        function createScoreParticles(x, y) {
            for (let i = 0; i < 10; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4 - 2,
                    life: 1.0,
                    size: Math.random() * 4 + 2,
                    color: `hsl(${Math.random() * 60 + 150}, 100%, 50%)` // Green to cyan
                });
            }
        }

        function createFlapParticles(x, y) {
            // Small particles when bird flaps
            for (let i = 0; i < 3; i++) {
                particles.push({
                    x: x,
                    y: y + 20,
                    vx: (Math.random() - 0.5) * 2,
                    vy: Math.random() * 2 + 1,
                    life: 0.5,
                    size: Math.random() * 3 + 1,
                    color: 'rgba(255, 255, 255, 0.8)'
                });
            }
        }

        function createCollisionParticles(x, y) {
            // Explosion effect on collision
            for (let i = 0; i < 20; i++) {
                const angle = (Math.PI * 2 * i) / 20;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * 5,
                    vy: Math.sin(angle) * 5,
                    life: 1.0,
                    size: Math.random() * 5 + 2,
                    color: `hsl(${Math.random() * 60}, 100%, 50%)` // Red to yellow
                });
            }
        }

        function updateParticles(timeScale = 1) {
            particles = particles.filter(p => {
                p.x += p.vx * timeScale;
                p.y += p.vy * timeScale;
                p.vy += 0.2 * timeScale; // Gravity
                p.life -= 0.02 * timeScale;
                return p.life > 0;
            });
        }

        function drawParticles() {
            particles.forEach(p => {
                ctx.save();
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });
        }

        // --- Background Functions ---
        function initBackground() {
            groundOffset = 0;
            clouds = [];
            particles = [];
            const w = canvas.logicalWidth || canvas.width;
            const h = canvas.logicalHeight || canvas.height;
            for (let i = 0; i < 5; i++) {
                clouds.push({
                    x: Math.random() * w,
                    y: Math.random() * (h / 2) + 20, // Top half of screen
                    radius: Math.random() * 20 + 20 // 20-40px radius
                });
            }
        }

        function updateBackground(timeScale = 1) {
            if (gameover) return; // Freeze background on game over
            const w = canvas.logicalWidth;
            groundOffset -= SPEED * timeScale;
            if (groundOffset <= -w) {
                groundOffset = 0;
            }

            clouds.forEach(cloud => {
                cloud.x -= CLOUD_SPEED * timeScale;
                if (cloud.x + cloud.radius * 2 < 0) {
                    cloud.x = w + cloud.radius * 2;
                    cloud.y = Math.random() * (canvas.logicalHeight / 2) + 20;
                }
            });
        }

        function drawBackground(w, h) {
            // Draw clouds with shadows and better rendering
            clouds.forEach(cloud => {
                ctx.save();
                
                // Cloud shadow
                ctx.shadowColor = 'rgba(0, 0, 0, 0.1)';
                ctx.shadowBlur = 10;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;
                
                // Cloud gradient for 3D effect
                const cloudGradient = ctx.createRadialGradient(cloud.x, cloud.y, 0, cloud.x, cloud.y, cloud.radius * 1.5);
                cloudGradient.addColorStop(0, 'rgba(255, 255, 255, 0.95)');
                cloudGradient.addColorStop(0.7, 'rgba(255, 255, 255, 0.85)');
                cloudGradient.addColorStop(1, 'rgba(240, 240, 240, 0.7)');
                ctx.fillStyle = cloudGradient;
                
                ctx.beginPath();
                // Enhanced fluffy cloud shape
                ctx.arc(cloud.x, cloud.y, cloud.radius, 0, Math.PI * 2);
                ctx.arc(cloud.x + cloud.radius * 0.8, cloud.y - cloud.radius * 0.3, cloud.radius * 0.8, 0, Math.PI * 2);
                ctx.arc(cloud.x - cloud.radius * 0.7, cloud.y - cloud.radius * 0.2, cloud.radius * 0.7, 0, Math.PI * 2);
                ctx.arc(cloud.x + cloud.radius * 0.3, cloud.y + cloud.radius * 0.4, cloud.radius * 0.6, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            });

            // Draw ground with gradient and texture
            const groundGradient = ctx.createLinearGradient(0, h - GROUND_HEIGHT, 0, h);
            groundGradient.addColorStop(0, '#10b981'); // Green grass
            groundGradient.addColorStop(0.15, '#059669'); // Darker green
            groundGradient.addColorStop(0.15, '#d4a574'); // Light brown earth
            groundGradient.addColorStop(1, '#a67c52'); // Darker brown

            ctx.fillStyle = groundGradient;
            ctx.fillRect(groundOffset, h - GROUND_HEIGHT, w, GROUND_HEIGHT);
            ctx.fillRect(groundOffset + w, h - GROUND_HEIGHT, w, GROUND_HEIGHT);

            // Add grass texture with small blades
            ctx.fillStyle = '#0d9488'; // Teal for grass variation
            for (let i = 0; i < 50; i++) {
                const x = (groundOffset + (i * w / 25)) % (w * 2);
                const y = h - GROUND_HEIGHT + Math.random() * 5;
                ctx.fillRect(x, y, 2, 8);
            }

            // Add dirt texture
            ctx.fillStyle = 'rgba(139, 90, 43, 0.3)';
            for (let i = 0; i < 30; i++) {
                const x = (groundOffset + (i * w / 15)) % (w * 2);
                const y = h - GROUND_HEIGHT + 20 + Math.random() * (GROUND_HEIGHT - 30);
                ctx.beginPath();
                ctx.arc(x, y, Math.random() * 3 + 1, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // --- Game Setup ---
        function setup() {
            // Update presence status
            updatePresenceStatus('playing');
            
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            canvas.logicalWidth = rect.width;
            canvas.logicalHeight = rect.height;
            
            initBackground(); // Initialize background elements

            bird = {
                x: canvas.logicalWidth / 3,
                y: canvas.logicalHeight / 2,
                width: BIRD_WIDTH,
                height: BIRD_HEIGHT,
                velocity: 0,
                rotation: 0
            };
            pipes = [];
            score = 0;
            highScore = localStorage.getItem('flappyHighScore') || 0;
            gameover = false;
            frame = 0;
            lastTime = 0; // Reset delta time tracking
            deltaTime = 0; // Reset delta time
            timeSinceLastPipe = 0; // Reset pipe spawn timer
            
            // Reset bird image flags
            showPassImage = false;
            showHitImage = false;
            
            // Anti-cheat: Initialize integrity tracking
            gameStartTime = Date.now();
            pipesPassed = 0;
            totalFlaps = 0;
            gameHash = simpleHash(playerId + gameStartTime + seed);
            
            // Reset seed for consistent pipe generation every game
            seed = 12345;
            
            // Spawn first pipe - further away on mobile for easier start
            const isMobile = window.innerWidth <= 767;
            const firstPipeDistance = isMobile ? 1.2 : 0.6; // Mobile: 120% screen width (off-screen), Desktop: 60%
            
            const dynamicPipeGap = Math.max(150, Math.min(PIPE_GAP, canvas.logicalHeight / 3));
            const minPipeHeight = 50;
            const maxPipeHeight = canvas.logicalHeight - dynamicPipeGap - minPipeHeight - GROUND_HEIGHT;
            const firstPipeHeight = seededRandom() * (maxPipeHeight - minPipeHeight) + minPipeHeight;
            
            pipes.push({
                x: canvas.logicalWidth * firstPipeDistance, // Mobile gets more time to prepare
                top: firstPipeHeight,
                bottom: firstPipeHeight + dynamicPipeGap,
                passed: false,
                isFirstPipe: true // Mark as first pipe for mobile spacing logic
            });
            
            scoreDisplay.textContent = score;
            
            // Smooth transition from start screen to game
            startScreen.style.opacity = '0';
            setTimeout(() => {
                startScreen.classList.add('hidden');
                scoreDisplay.classList.remove('hidden');
                scoreDisplay.style.animation = 'slideDown 0.5s ease-out';
            }, 300);
            
            gameOverScreen.classList.add('hidden');
            gameOverScreen.style.display = 'none';
            // Remove new high score animation if present
            const scoreEl = document.getElementById('finalScore');
            if (scoreEl) scoreEl.classList.remove('new-high-score');
            
            gameLoop();
        }

        // --- Game Loop ---
        function gameLoop(currentTime = 0) {
            if (gameover) return;
            
            // Calculate delta time (time since last frame in seconds)
            if (lastTime === 0) lastTime = currentTime;
            deltaTime = (currentTime - lastTime) / 1000; // Convert to seconds
            lastTime = currentTime;
            
            // Cap delta time to prevent huge jumps (e.g., when tab is inactive)
            deltaTime = Math.min(deltaTime, 0.1);
            
            update();
            draw();
            frame++;
            requestAnimationFrame(gameLoop);
        }

        // --- Update Logic ---
        function update() {
            // Anti-cheat: Detect if game variables are being tampered with
            if (typeof bird === 'undefined' || typeof pipes === 'undefined' || typeof score === 'undefined') {
                console.error('üö´ Game tampering detected! Variables modified.');
                return endGame();
            }
            
            // Use 60 FPS as baseline (1/60 = 0.0166... seconds per frame)
            const timeScale = deltaTime > 0 ? deltaTime / (1/60) : 1;
            
            bird.velocity += GRAVITY * timeScale;
            bird.y += bird.velocity * timeScale;

            if (bird.velocity < 0) {
                bird.rotation = -0.3; 
            } else {
                bird.rotation = Math.min(Math.PI / 4, bird.velocity * 0.05);
            }

            // Ground collision
            if (bird.y + bird.height / 2 > canvas.logicalHeight - GROUND_HEIGHT) {
                bird.y = canvas.logicalHeight - GROUND_HEIGHT - bird.height / 2;
                bird.velocity = 0;
                
                // Show hit image (if configured)
                if (birdHitImage) {
                    showHitImage = true;
                    showPassImage = false;
                }
                
                return endGame();
            }
            // Sky collision
            if (bird.y - bird.height / 2 < 0) {
                bird.y = bird.height / 2;
                bird.velocity = 0;
            }

            // Pipe management
            // Check if it's time to spawn a new pipe based on elapsed time (not frames)
            // This ensures consistent pipe spacing across all refresh rates
            const pipeSpawnTime = PIPE_SPACING / SPEED / 60; // Time in seconds (60 FPS baseline)
            timeSinceLastPipe += deltaTime;
            
            if (timeSinceLastPipe >= pipeSpawnTime) {
                timeSinceLastPipe = 0; // Reset timer 
                const dynamicPipeGap = Math.max(150, Math.min(PIPE_GAP, canvas.logicalHeight / 3)); // Ensure gap is reasonable
                const minPipeHeight = 50;
                const maxPipeHeight = canvas.logicalHeight - dynamicPipeGap - minPipeHeight - GROUND_HEIGHT; // Don't let pipes go into ground
                
                // Use seeded random for consistent pipe heights every game
                const pipeHeight = seededRandom() * (maxPipeHeight - minPipeHeight) + minPipeHeight;
                
                pipes.push({
                    x: canvas.logicalWidth,
                    top: pipeHeight,
                    bottom: pipeHeight + dynamicPipeGap,
                    passed: false,
                    isFirstPipe: false
                });
            }

            // Anti-cheat: Track collision state to prevent bypassing
            let collisionDetected = false;
            
            pipes.forEach(pipe => {
                pipe.x -= SPEED * timeScale;

                // Collision detection - CANNOT BE BYPASSED
                const birdLeft = bird.x - bird.width / 2;
                const birdRight = bird.x + bird.width / 2;
                const birdTop = bird.y - bird.height / 2;
                const birdBottom = bird.y + bird.height / 2;

                const pipeRight = pipe.x + PIPE_WIDTH;

                // Multiple collision checks to prevent bypassing
                const horizontalCollision = birdRight > pipe.x && birdLeft < pipeRight;
                const topCollision = birdTop < pipe.top;
                const bottomCollision = birdBottom > pipe.bottom;

                if (horizontalCollision && (topCollision || bottomCollision)) {
                    collisionDetected = true;
                    console.error('üö´ Pipe collision detected!');
                    
                    // Show hit image (if configured)
                    if (birdHitImage) {
                        showHitImage = true;
                        showPassImage = false; // Override pass image if showing
                    }
                }

                // Score
                if (!pipe.passed && pipe.x < bird.x) {
                    pipe.passed = true;
                    pipesPassed++; // Anti-cheat: Track pipes
                    
                    // Anti-cheat: Verify score matches pipes passed
                    if (score !== pipesPassed - 1) {
                        console.error('üö´ Score tampering detected!');
                        collisionDetected = true;
                    }
                    
                    score++;
                    scoreDisplay.textContent = score;
                    
                    // Play pass sound
                    playPassSound();
                    
                    // Show pass image temporarily (if configured)
                    if (birdPassImage) {
                        showPassImage = true;
                        setTimeout(() => {
                            showPassImage = false;
                        }, 1500); // Show for 1.5 seconds
                    }
                    
                    // Create particle effect at score location
                    createScoreParticles(canvas.logicalWidth / 2, 60);
                    
                    // Score pop animation
                    scoreDisplay.style.transform = 'translate(-50%, 0) scale(1.3)';
                    setTimeout(() => {
                        scoreDisplay.style.transform = 'translate(-50%, 0) scale(1)';
                    }, 200);
                }
            });

            // Force end game if collision was detected (cannot be bypassed)
            if (collisionDetected) {
                return endGame();
            }

            // Remove off-screen pipes
            pipes = pipes.filter(pipe => pipe.x + PIPE_WIDTH > 0);

            // Update background and particles
            updateBackground();
            updateParticles();
        }

        // --- Draw Logic ---
        function draw() {
            const w = canvas.logicalWidth;
            const h = canvas.logicalHeight;

            // Clear any previous shadow settings
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;

            // Draw Sky with gradient
            const skyGradient = ctx.createLinearGradient(0, 0, 0, h);
            skyGradient.addColorStop(0, '#87ceeb'); // Light sky blue at top
            skyGradient.addColorStop(0.7, '#70c5ce'); // Flappy bird sky blue
            skyGradient.addColorStop(1, '#5fb3c1'); // Slightly darker at bottom
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, w, h);

            // Draw Background elements (clouds, ground)
            drawBackground(w, h);

            // Draw Particles (before pipes so they appear behind)
            drawParticles();

            // Draw Pipes
            pipes.forEach(pipe => {
                // Create gradient for pipes
                const pipeGradient = ctx.createLinearGradient(pipe.x, 0, pipe.x + PIPE_WIDTH, 0);
                pipeGradient.addColorStop(0, '#34d399'); // lighter emerald
                pipeGradient.addColorStop(0.3, '#10b981'); // emerald-500
                pipeGradient.addColorStop(0.7, '#059669'); // darker emerald
                pipeGradient.addColorStop(1, '#047857'); // even darker

                // Add shadow behind pipes
                ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
                ctx.shadowBlur = 10;
                ctx.shadowOffsetX = 4;
                ctx.shadowOffsetY = 0;

                // Draw top pipe with gradient
                ctx.fillStyle = pipeGradient;
                ctx.fillRect(pipe.x, 0, PIPE_WIDTH, pipe.top);

                // Draw bottom pipe with gradient
                ctx.fillRect(pipe.x, pipe.bottom, PIPE_WIDTH, h - pipe.bottom - GROUND_HEIGHT);

                // Clear shadow for caps
                ctx.shadowColor = 'transparent';

                // Add caps with gradient
                const capHeight = 25; 
                const capOverlap = 5; 
                
                const capGradient = ctx.createLinearGradient(pipe.x - capOverlap, 0, pipe.x + PIPE_WIDTH + capOverlap, 0);
                capGradient.addColorStop(0, '#6ee7b7'); // very light emerald
                capGradient.addColorStop(0.5, '#10b981'); // emerald-500
                capGradient.addColorStop(1, '#065f46'); // very dark emerald

                // Top pipe cap with shadow
                ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                ctx.shadowBlur = 5;
                ctx.shadowOffsetY = 2;
                ctx.fillStyle = capGradient;
                ctx.fillRect(pipe.x - capOverlap, pipe.top - capHeight, PIPE_WIDTH + capOverlap * 2, capHeight);
                
                // Top cap shine
                ctx.shadowColor = 'transparent';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.fillRect(pipe.x - capOverlap, pipe.top - capHeight, PIPE_WIDTH + capOverlap * 2, capHeight * 0.3);

                // Bottom pipe cap with shadow
                ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                ctx.shadowBlur = 5;
                ctx.shadowOffsetY = 2;
                ctx.fillStyle = capGradient;
                ctx.fillRect(pipe.x - capOverlap, pipe.bottom, PIPE_WIDTH + capOverlap * 2, capHeight);
                
                // Bottom cap shine
                ctx.shadowColor = 'transparent';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.fillRect(pipe.x - capOverlap, pipe.bottom, PIPE_WIDTH + capOverlap * 2, capHeight * 0.3);

                // Add vertical highlight stripe on pipes
                ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
                ctx.fillRect(pipe.x + PIPE_WIDTH * 0.15, 0, PIPE_WIDTH * 0.15, pipe.top);
                ctx.fillRect(pipe.x + PIPE_WIDTH * 0.15, pipe.bottom, PIPE_WIDTH * 0.15, h - pipe.bottom - GROUND_HEIGHT);
            });

            // Draw Bird
            ctx.save();
            ctx.translate(bird.x, bird.y);
            ctx.rotate(bird.rotation);
            
            // Use hit image if collision occurred (highest priority), pass image if just scored, otherwise normal image
            let currentBirdImage = birdImage;
            if (showHitImage && birdHitImage) {
                currentBirdImage = birdHitImage;
            } else if (showPassImage && birdPassImage) {
                currentBirdImage = birdPassImage;
            }
            
            if (currentBirdImage) {
                // Calculate scale to fit within BIRD_WIDTH/HEIGHT while maintaining aspect ratio
                const aspectRatio = currentBirdImage.width / currentBirdImage.height;
                let drawWidth = BIRD_WIDTH;
                let drawHeight = BIRD_HEIGHT;

                // We want to fit it inside the square bounds
                if (aspectRatio > 1) { // Wide image
                    drawHeight = BIRD_WIDTH / aspectRatio;
                    drawWidth = BIRD_WIDTH;
                } else { // Tall or square image
                    drawWidth = BIRD_HEIGHT * aspectRatio;
                    drawHeight = BIRD_HEIGHT;
                }
                
                // Add drop shadow and glow effect
                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                ctx.shadowBlur = 15;
                ctx.shadowOffsetX = 3;
                ctx.shadowOffsetY = 3;
                
                ctx.drawImage(currentBirdImage, -drawWidth / 2, -drawHeight / 2, drawWidth, drawHeight);
                
                // Add subtle glow
                ctx.shadowColor = 'rgba(255, 255, 255, 0.3)';
                ctx.shadowBlur = 10;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
                ctx.drawImage(currentBirdImage, -drawWidth / 2, -drawHeight / 2, drawWidth, drawHeight);
            } else {
                // Default bird with gradient and shadow
                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                ctx.shadowBlur = 15;
                ctx.shadowOffsetX = 3;
                ctx.shadowOffsetY = 3;
                
                const gradient = ctx.createLinearGradient(-bird.width / 2, -bird.height / 2, bird.width / 2, bird.height / 2);
                gradient.addColorStop(0, '#fbbf24'); // yellow-400
                gradient.addColorStop(1, '#f59e0b'); // yellow-600
                ctx.fillStyle = gradient;
                ctx.fillRect(-bird.width / 2, -bird.height / 2, bird.width, bird.height);
                
                // Add highlight
                ctx.shadowColor = 'transparent';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.fillRect(-bird.width / 2, -bird.height / 2, bird.width / 4, bird.height / 4);
            }
            
            ctx.restore();
        }

        // --- Game State Functions ---
        function flap() {
            if (!gameover) {
                totalFlaps++; // Anti-cheat: Track flaps
                bird.velocity = FLAP_STRENGTH;
                playFlapSound();
                // Create flap particles for visual feedback
                createFlapParticles(bird.x, bird.y);
            }
        }

        function endGame() {
            if (gameover) return; 
            gameover = true;
            
            // Show hit image on game over (if configured)
            if (birdHitImage) {
                showHitImage = true;
                showPassImage = false;
            }
            
            // Update presence status
            updatePresenceStatus('viewing_score');
            
            playOutSound();
            
            // Create collision explosion effect
            createCollisionParticles(bird.x, bird.y);
            
            // Shake animation on game over
            canvas.style.animation = 'shake 0.5s';
            setTimeout(() => {
                canvas.style.animation = '';
            }, 500);
            
            let isNewHighScore = false;
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('flappyHighScore', highScore);
                isNewHighScore = true;
            }
            finalScore.textContent = score;
            highScoreDisplay.textContent = highScore;
            
            // Save score to Firebase
            if (playerName && score > 0) {
                saveScoreToFirebase(playerName, score);
            }
            
            // Animate game over screen appearance
            setTimeout(() => {
                scoreDisplay.classList.add('hidden');
                playerNameDisplay.classList.add('hidden');
                gameOverScreen.classList.remove('hidden');
                gameOverScreen.style.display = 'flex';
                gameOverScreen.style.animation = 'fadeIn 0.4s ease-out';
                
                // Add new high score glow effect
                if (isNewHighScore && score > 0) {
                    const scoreEl = document.getElementById('finalScore');
                    if (scoreEl) scoreEl.classList.add('new-high-score');
                }
                
                // Load leaderboard
                loadLeaderboard();
            }, 300);
        }

        function startGame() {
            initAudio();
            Tone.start(); 

            // Stop any lingering sounds
            if (outAudio) {
                outAudio.pause();
                outAudio.currentTime = 0;
            }
            if (outSynth) {
                outSynth.triggerRelease();
            }

            setup();
        }

        // --- Event Listeners ---
        saveNameButton.addEventListener('click', () => {
            const name = playerNameInput.value.trim();
            if (name.length > 0) {
                savePlayerName(name);
                hideNameEntry();
                startScreen.classList.remove('hidden');
            } else {
                alert('Please enter a name!');
            }
        });

        playerNameInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                saveNameButton.click();
            }
        });

        changeNameButton.addEventListener('click', () => {
            gameOverScreen.classList.add('hidden');
            gameOverScreen.style.display = 'none';
            showNameEntry();
        });

        startButton.addEventListener('click', startGame);
        restartButton.addEventListener('click', startGame);

        canvas.addEventListener('mousedown', flap);
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault(); 
            flap();
        });
        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space' || e.code === 'ArrowUp' || e.key === ' ') {
                e.preventDefault(); // Prevent spacebar from scrolling
                if (startScreen.classList.contains('hidden') && gameOverScreen.classList.contains('hidden')) {
                    flap();
                } else if (!startScreen.classList.contains('hidden')) {
                    startGame();
                } else if (!gameOverScreen.classList.contains('hidden')) {
                    startGame();
                }
            }
        });

        window.addEventListener('resize', () => {
            // Re-setup the canvas and game state on resize
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            canvas.logicalWidth = rect.width;
            canvas.logicalHeight = rect.height;

            if (gameover) {
                // If game is over, just redraw the end screen
                draw(); // Redraw static elements
                drawBackground(canvas.logicalWidth, canvas.logicalHeight);
            } else if (!startScreen.classList.contains('hidden')) {
                // If on start screen, just redraw background
                initialScreenSetup();
            } else {
                // If game is running, restart it to avoid weird scaling issues
                setup();
            }
        });

        function initialScreenSetup() {
            // Set title from config
            document.getElementById('gameTitle').textContent = GAME_TITLE;
            // Load developer-defined assets
            loadDeveloperAssets();

            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            canvas.logicalWidth = rect.width;
            canvas.logicalHeight = rect.height;

            // Draw sky with gradient
            const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.logicalHeight);
            skyGradient.addColorStop(0, '#87ceeb');
            skyGradient.addColorStop(0.7, '#70c5ce');
            skyGradient.addColorStop(1, '#5fb3c1');
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, canvas.logicalWidth, canvas.logicalHeight);
            
            initBackground();
            drawBackground(canvas.logicalWidth, canvas.logicalHeight);

            scoreDisplay.classList.add('hidden');
            playerNameDisplay.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            gameOverScreen.style.display = 'none';
            
            // Check if player has a name, otherwise show name entry
            if (playerName) {
                currentPlayerName.textContent = playerName;
                startScreen.classList.remove('hidden');
                startScreen.style.opacity = '1';
                nameEntryScreen.classList.add('hidden');
            } else {
                startScreen.classList.add('hidden');
                showNameEntry();
            }
        }

        initialScreenSetup();

        // --- Admin Controls ---
        // Show clear button when Shift+Click on leaderboard title
        const leaderboardContainer = document.getElementById('leaderboardContainer');
        const clearBtn = document.getElementById('clearLeaderboardBtn');
        let shiftClicks = 0;
        
        leaderboardContainer.addEventListener('click', (e) => {
            if (e.shiftKey) {
                shiftClicks++;
                if (shiftClicks >= 3) {
                    clearBtn.classList.remove('hidden');
                    console.log('üîì Admin mode activated - Clear button visible');
                }
            }
        });

        // Clear button event listener
        clearBtn.addEventListener('click', () => {
            if (confirm('‚ö†Ô∏è Clear entire leaderboard?\n\nThis will remove:\n- All leaderboard scores\n- Your player name\n- Your high score\n\nThis action cannot be undone!')) {
                clearAllData();
                location.reload();
            }
        });
        
        console.log('üéÆ Game Commands Available:');
        console.log('  - clearLeaderboard() : Clear the leaderboard');
        console.log('  - clearAllData() : Clear all game data (leaderboard, name, ID, high score)');
        console.log('');
        console.log('üí° Quick Clear: Hold Shift and click leaderboard 3 times to show clear button');

    </script>
</body>
</html>